<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Sian</title>
    <link>https://sunnyday0932.github.io/posts/</link>
    <description>Recent content in Posts on Sian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sun, 06 Dec 2020 12:01:15 +0800</lastBuildDate><atom:link href="https://sunnyday0932.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hugo主題Leaveit錯誤修改</title>
      <link>https://sunnyday0932.github.io/2020/hugo%E4%B8%BB%E9%A1%8Cleaveit%E9%8C%AF%E8%AA%A4%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sun, 06 Dec 2020 12:01:15 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/hugo%E4%B8%BB%E9%A1%8Cleaveit%E9%8C%AF%E8%AA%A4%E4%BF%AE%E6%94%B9/</guid>
      <description>本文 之前Google Console不斷提醒網頁結構有問題。
就是這個&amp;hellip;
之前都直接手動修改，昨天心血來潮決定把源頭找出來到底出在哪裡
經過同事幫忙，發現在主題資料夾下有一個seo_schema.html檔案。
詳細路徑在themes\LeaveIt\layouts\partials\seo_schema.html
裡面長這樣： 一開始裡面就少了一個括號，只要把這邊補上就正常啦。
{ &amp;quot;@context&amp;quot; : &amp;quot;http://schema.org&amp;quot;, &amp;quot;@type&amp;quot; : &amp;quot;BlogPosting&amp;quot;, &amp;quot;mainEntityOfPage&amp;quot;: { &amp;quot;@type&amp;quot;: &amp;quot;WebPage&amp;quot;, &amp;quot;@id&amp;quot;: &amp;quot;{{ .Site.BaseURL }}&amp;quot; }, &amp;quot;articleSection&amp;quot; : &amp;quot;{{ .Section }}&amp;quot;, &amp;quot;name&amp;quot; : &amp;quot;{{ .Title }}&amp;quot;, &amp;quot;headline&amp;quot; : &amp;quot;{{ .Title }}&amp;quot;, &amp;quot;description&amp;quot; : &amp;quot;{{ if .Description }}{{ .Description }}{{ else }}{{if .IsPage}}{{ .Summary }}{{ end }}{{ end }}&amp;quot;, &amp;quot;inLanguage&amp;quot; : &amp;quot;{{ .Site.LanguageCode }}&amp;quot;, &amp;quot;author&amp;quot; : &amp;quot;{{ if isset .Params &amp;quot;author&amp;quot; }}{{ .</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 0</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</link>
      <pubDate>Thu, 03 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</guid>
      <description>前言 前面介紹了三層式架構、DI，接下來就是要來實做啦。
這次的實作會自己設計一張Table，並設計API情境，當練習寫SPEC；所以這篇是前置動作準備。
本文 1、資料庫準備。 首先這次打算做一個使用者管理功能，所以先來建造Table，就直接放在先前的Norwind底下就可以了。
CREATE TABLE Users ( Idx INT IDENTITY, Account varchar(30) PRIMARY KEY NOT NULL, Password varchar(50) NOT NULL, Phone varchar(20) NOT NULL, Email varchar(50) NOT NULL, CreateDate DATETIME NOT NULL, ModifyDate DATETIME NOT NULL, ModifyUser varchar(30) NOT NULL ); 建立完後重新整理即可在Northwind底下看到新Table。
新增一筆資料測試。
Insert into [Northwind].[dbo].[Users] ([Account] ,[Password] ,[Phone] ,[Email] ,[CreateDate] ,[ModifyDate] ,[ModifyUser]) values(&#39;ss123456&#39;,&#39;esetttt&#39;,&#39;0917444&#39;,&#39;ew@gmail.com&#39;,GETDATE(),GETDATE(),&#39;system&#39;) 2、API SPEC。 首先我們會需要的功能有：
   功能     1、新增使用者。   2、取得所有使用者。   3、取得個別使用者。   4、刪除使用者。   5、使用者更新基本資料。   6、忘記密碼。    功能細項規格：</description>
    </item>
    
    <item>
      <title>依賴注入 DI(Dependency Injection)</title>
      <link>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</link>
      <pubDate>Wed, 02 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</guid>
      <description>前言 終於寫到DI了，這應該是一開始學習三層式架構後的第二座高山，直到今天我也還不敢稱自己完全懂，頂多只能說是會用，剛好藉著這次機會複習概念。
本文 講解DI前會有兩個先行觀念需要了解，分別是：
 1、DIP(Dependency Inversion Principle) 依賴反轉。 2、IOC(Inversion of Control) 控制反轉。  1、DIP 依賴反轉。 複習一下前面講解到的依賴反轉概念：
我們了解到DIP最重要的目標是要解除物件與物間之間直接依賴的關係。
不熟的同學起點這複習。
2、IOC 控制反轉。 那甚麼又是控制反轉呢？
控制反轉最重要的概念是：
把對於某個物件的控制權移轉給第三方容器。 甚麼意思呢？
回憶一下，還記得前面實作的第一版API嗎？
我們的Controller在跟Repository要資料的時候是怎麼做的呢？ 看到關鍵字了嗎？
沒有？那這樣呢？
就是那個NEW代表著我們的Controller其實是直接依賴Repository的。
他們之間的關係如下圖。
所以理想中IOC概念我們的關係圖應該長這樣： 我們的Controller應該把對於Repository的控制權移交給IOC。
3、DI 依賴注入。 講了這麼多那所以甚麼是DI呢？
聰明的同學應該發現了上述的DIP、IOC都只是一種精神、概念；而DI就是實現上述兩種精神的方法。
講解DI的精神最經典的就是：  好萊塢原則 (Hollywood Principle)
don‘t call us, we‘ll call you
在好萊塢演員要應徵的時候僅需要把履歷上繳，之後剩下的就只能等待演藝公司通知。
這就是一種被動接受的方式。  所以呢有了DI的概念我們理想中的關係圖應該要變成： 4、注入的方式。 注入的方式有以下三種：
 a、建構式注入 (Constructor Injection) b、設值方法注入 (Setter Injection) c、介面注入 (Interface Injection)  以我們先前的Controller進行示範
public class ProductContorller : ControllerBase { //a、建構式注入 private readonly IProductRepository _productRepository; public ProductContorller( IProductRepository productRepository) { this.</description>
    </item>
    
    <item>
      <title>SQL 模糊搜尋Like替代方式</title>
      <link>https://sunnyday0932.github.io/2020/sql-%E6%A8%A1%E7%B3%8A%E6%90%9C%E5%B0%8Blike%E6%9B%BF%E4%BB%A3%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 27 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/sql-%E6%A8%A1%E7%B3%8A%E6%90%9C%E5%B0%8Blike%E6%9B%BF%E4%BB%A3%E6%96%B9%E5%BC%8F/</guid>
      <description>本文 今天在查找SQL效能Like會引起吃不到索引的情況忽然學會一招，一定要趕快紀錄一下。
在處理模糊搜尋的條件常常會使用LIKE&#39;%關鍵字%&amp;lsquo;這種做法，但SQL的索引在LIKE&amp;rsquo;%關鍵字&amp;rsquo;的情況會失效，更不用說使用LIKE&#39;%關鍵字%&amp;lsquo;當資料一大效能真的是非常差。
這裡介紹一個替代使用語法 CHARINDEX。
首先我們先看一下MSDN介紹用法。
這裡可以知道charindex其實是可以用來計算兩個字元間有多少相同的地方。
現在來測試一下
SELECT CHARINDEX(&#39;a&#39;,&#39; apple is apple&#39;) 結果：
或是可以用來判斷相同的字元出現的位子。
SELECT CHARINDEX(&#39;a&#39;,&#39;appleisapple&#39;,5) 結果： 這邊第三個參數5是從第五個字元開始往後搜尋。
所以如果改成0結果就會是
SELECT CHARINDEX(&#39;a&#39;,&#39;appleisapple&#39;,0) 結果： 替代LIKE的方式 好了說了這麼多到底要怎麼替代LIKE呢？
可以使用這種方式替代
CHARINDEX(&#39;模糊搜尋關鍵字&#39;, 要搜尋的資料行) &amp;gt; 0 實際測試，使用NorthWind Product Table
SELECT * FROM [Northwind].[dbo].[Products] where CHARINDEX(&#39;a&#39;,ProductName) &amp;gt; 0 使用CHARINDEX結果： SELECT * FROM [Northwind].[dbo].[Products] where ProductName LIKE &#39;%a%&#39; 使用LIKE結果： 哪種方式比較好？ 因為在家裡沒有這麼大量的資料做測試，在公司的時候實際測試，如果再沒有吃到索引的情況下CHARINDEX會比LIKE還要快，但如果有吃到索引LIKE的速度還是優於CHARINDEX的。
所以如果在非得需要進行LIKE&amp;rsquo;%關鍵字%&amp;lsquo;搜尋資料時，沒辦法吃到索引，就可以使用CHARINDEX來替代LIKE，大家可以自行測試看看。
參考資料  1、CHARINDEX。 2、SqlServer之like、charindex、patindex區別及性能分析。  </description>
    </item>
    
    <item>
      <title>Automapper 類別轉換好用工具</title>
      <link>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>前言 上一篇介紹了三層式架構，有些人可能會有疑問，三層各有自己的Model，那要怎麼將各個Model轉換呢？
難道是每一次轉換都需要跑一次迴圈，那也太麻煩了；這時就要介紹好用的工具Automapper了。
本文 基本用法 首先到Nuget安裝Automapper。 安裝好後我們建立兩個測試用的Model
private class Model1 { public string Name { get; set; } public int Id { get; set; } } private class Model2 { public string Name { get; set; } public int Id { get; set; } } 使用Automapper對應Model1到Model2。
var testModel = new Model1 { Name = &amp;quot;ALLEN&amp;quot;, Id = 1 }; var config = new MapperConfiguration(cfg =&amp;gt; cfg.CreateMap&amp;lt;Model1, Model2&amp;gt;()); //從左邊Model對應到右邊 var mapper = config.</description>
    </item>
    
    <item>
      <title>三層式架構</title>
      <link>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</link>
      <pubDate>Sun, 15 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</guid>
      <description>前言 接下來開始講解三層式架構，這是工作以來第一個學會的架構，也使用了一段時間，就以這段時間自己的體悟來敘述。
本文 為甚麼要分層呢？ 前一篇我們提到，如果程式全部一條龍寫到底，後續會產生很多問題，難以維護、難以閱讀、更甚至是萬一人家要接手你的程式碼，這時候改Ａ壞Ｂ，耦合度過高的情況下，你只能祈禱接手的人不知道你住哪。
這種情況下只有自己寫可能還好，那如果需要跟人合作呢？
大家可能容易出現重複的Code，也難以說明誰該負責寫哪部分。
這時候有一個好的架構，就很重要了。
優缺點    優點     1、較好形成一個規範，可做為標準化流程。   2、提高重用性，透過分層將相同類型的程式碼放在一塊。   3、團體合作的時候，能夠分層進行；開發人員只需專注於自己開發的那一層即可。   4、具有好的開放性、可擴充性優點。   5、降低程式碼之間的依賴，每層溝通是透過介面。   6、提高系統安全性，因為使用者需要透過Service層才有機會與下一層Repository撈取資料。       缺點     1、增加了開發成本，傳統一個人負責寫到底；分層下需要多人進行合作。   2、調整程式可能會出現連動性；有的時候修改一個地方，會導致其他層也需要跟著調整。   3、相較於一條龍開發系統性能下降，原本程式可以直接透過DB撈取資料，現在需要透過中間層的轉介才能夠拿到。    簡介 三層式架構顧名思義，主要分為了三層：
 1、Controller：控制層，作為接口。 2、Service：商業邏輯層，只要有關商業邏輯部分的處理全部放在這一層。 3、Repository：倉儲層，作為資料存儲的一層。 4、Common：共用層，作為存放各層會用到的相同東西。  他們之間的關係如下圖:
Service 從最重要的Service層開始講解起。
在我們程式中『最重要』的就屬於商業邏輯了，這一層是會特別關注的一層；這邊大家可能會問，那商業邏輯是指哪些呢？
我自己認為最簡單分辨的方式，舉凡任何需要對資料特別處理的地方都會是放在這一層，如常見的：登入驗證、加減法運算、確認是否驗證成功等。
Controller 在我們WebAPI中，Controller就屬於接口，負責處理Router，如常見的：Get、Post、Patch等，都會是在這層負責接應相對應的路由。
Repository 資料倉儲層，這層主要處理『有關資料串接』的部分，如：資料庫連接、下SQL取Table資料等，都會是在Repository處理。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-5 小結分析</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 10 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</guid>
      <description>本文 先前完成了API，接下來聊聊目前這樣做法可能會碰到的問題。
1、程式碼四散。 現在做法是從Controller決定執行動作後，到Repository撈取DB資料後回傳json；那麼今天假如有要處理的關鍵商業邏輯，是該寫在Controller或是Repository呢？
又如果今天多人合作的情況下，甲覺得應該放在Repository、而乙覺得應該放在Controller，這樣就會造成程式碼四散，對後續要維護的人造成很大的困擾。
2、容易有重工。 現行做法如果多人合作的時候，可以用Repository名稱來定義是從哪個DB撈取資料；Controller也可以明確定義出接口，那承上所述的商業邏輯呢？又或是因為大家要處理的Model不同因此再合作的時候建了一堆不同的Model出來，卻其實是撈同一個Table的資料，應該想辦法避免做重複的事情。
3、耦合過高。 現行做法很容易再單一的class做了太多事，還記得前幾篇提到的SOLID原則嗎？若所有事情都包在同一個class中完成，藕合度就會過高這種情況應該要想辦法解決。
那有甚麼好方法呢？ 像傳統的MVC就是把程式分成Model-View-Controller。
 1、Model：處理商業邏輯、資料傳輸的Model、與資料庫進行溝通。 2、Controller：負責當接口、控制程式的流程。 3、View：負責呈現，ex:畫面啦、程式應該回傳的結果。  透過將程式分開讓藕合性降低、也讓後續維護者好維護。
其他如:DDD、三層式架構等，都有自己得優缺點，下篇我們會介紹三層式架構，再將API實作。
參考連結  1、維基百科MVC。 2、MVC 架構與說明 ( 以Asp .Net MVC C# 為例 ) 3、MVC 三層架構 是什麼? 我只知道三層肉  </description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-4 RESTful API介紹</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Thu, 29 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</guid>
      <description>本文 REST是Representational State Transfer的縮寫，是一種設計模式，RESTful API就是遵循這種設計模式所創造的API。
那RESTful是怎樣的一個設計模式呢? 首先組成RESTful API三大要素有:
   組成要素 說明     1、Nouns (名詞) 一組獨一無二的URL用來定義網址。   2、Verbs (動詞) 用來描述對URL所執行的動作，也就是HTTP Method。   3、Content Types(資源呈現方式) API資源呈現的方式 EX:JSON、XML。    以前幾篇的API為範例:
   Method router 說明     GET api/Product 取得商品列表   POST api/Product 新增商品   PATCH api/Product 修改商品資訊   DELETE api/Product/85 商除指定商品    固定的Router，但使用Method來區分要進行的動作，好處是不會有五花八門的router出現，一旦用了此種模式，大家就能輕易區分API會做些甚麼，我該取用哪隻API。
常見的Method有以下幾種:
   Method 說明     GET 讀取資料   POST 新增資料，亦可作為其他動詞使用。   PUT 更新   PATCH 部分更新資料   DELETE 刪除資料    備註: POST被視作萬用動詞，可以作為其他動作。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-3</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</link>
      <pubDate>Mon, 12 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</guid>
      <description>本文 修改 1、修改指定商品 Repository
/// &amp;lt;summary&amp;gt;  /// 修改商品內容  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;productModel&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool UpdateProduct(ProductModel productModel) { var sql = @&amp;#34;UPDATE products SET productname = @ProductName, supplierid = @SupplierID, categoryid = @CategoryID, quantityperunit = @QuantityPerUnit, unitprice = @UnitPrice, unitsinstock = @UnitsInStock, unitsonorder = @UnitsOnOrder, reorderlevel = @ReorderLevel, discontinued = @Discontinued WHERE productid = @ProductID &amp;#34;; var parameters = new DynamicParameters(); parameters.Add(&amp;#34;@ProductName&amp;#34;, productModel.ProductName); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-2</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</link>
      <pubDate>Tue, 29 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</guid>
      <description>前言 我們接續著上次的介紹，會把CRUD功能補齊。
CRUD指的是Create(新增)、Read(查詢)、Delete(刪除)、Update(更新)，也是最常運用到的功能。
本文 新增 1、首先我們先建立一個用來回傳的Model。
建立 ResultModel
public class ResultModel { /// &amp;lt;summary&amp;gt;  /// 結果  /// &amp;lt;/summary&amp;gt;  public bool Result { get; set; } /// &amp;lt;summary&amp;gt;  /// 提示訊息  /// &amp;lt;/summary&amp;gt;  public string Message { get; set; } } 2、把新增商品的Repository完成。
新增商品Repository
/// &amp;lt;summary&amp;gt; /// 新增一筆商品 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;productModel&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool CreateProduct(ProductModel productModel) { var sql = @&amp;quot;INSERT INTO products (productname, supplierid, categoryid, quantityperunit, unitprice, unitsinstock, unitsonorder, reorderlevel, discontinued) VALUES (@ProductName, @SupplierID, @CategoryID, @QuantityPerUnit, @UnitPrice, @UnitsInStock, @UnitsOnOrder, @ReorderLevel, @Discontinued) &amp;quot;; var parameters = new DynamicParameters(); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper)-1</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</link>
      <pubDate>Tue, 22 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</guid>
      <description>前言 終於進入WebApi部分，也是目前工作最常做的一部分。
這邊會從原始MVC作為開頭介紹，內容會帶入Dapper、Restful介紹，以及一些好用小工具分享。
本文 一、事前準備 1、首先我們先建立一個core專案。 選擇API建立 2、資料庫準備。 先到此連結下載北風資料庫
點選instnwnd.sql，選擇Download。 會看到瀏覽器顯示一長串SQL語法，把這邊全部複製起來。 到SSMS點選新增查詢，把語法貼上後執行。 看到資料庫出現Northwind代表成功。 二、API開發 1、首先我們建立一個Models資料夾。 建立一個ProductModel類別，對應北風資料庫的Products。 建立 ProductModel
public class ProductModel { /// &amp;lt;summary&amp;gt;  /// 商品流水號  /// &amp;lt;/summary&amp;gt;  public int ProductID { get; set; } /// &amp;lt;summary&amp;gt;  /// 商品名稱  /// &amp;lt;/summary&amp;gt;  public string ProductName { get; set; } /// &amp;lt;summary&amp;gt;  /// 供應商ID  /// &amp;lt;/summary&amp;gt;  public int SupplierID { get; set; } /// &amp;lt;summary&amp;gt;  /// 種類ID  /// &amp;lt;/summary&amp;gt;  public int CategoryID { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位數量  /// &amp;lt;/summary&amp;gt;  public string QuantityPerUnit { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位價格  /// &amp;lt;/summary&amp;gt;  public decimal UnitPrice { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位稅額  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsInStock { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位訂購價  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsOnOrder { get; set; } /// &amp;lt;summary&amp;gt;  /// 重新訂購等級  /// &amp;lt;/summary&amp;gt;  public Int16 ReorderLevel { get; set; } /// &amp;lt;summary&amp;gt;  /// 是否已停產  /// &amp;lt;/summary&amp;gt;  public bool Discontinued { get; set; } } 這邊各欄位的型態可以先看DB內資料類型</description>
    </item>
    
    <item>
      <title>軟體工程師資歷一年心得分享</title>
      <link>https://sunnyday0932.github.io/2020/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E8%B3%87%E6%AD%B7%E4%B8%80%E5%B9%B4%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</link>
      <pubDate>Fri, 04 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E8%B3%87%E6%AD%B7%E4%B8%80%E5%B9%B4%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</guid>
      <description>前言 有鑑於真的被問了不少次，所以就以分享的角度來回覆一些相關問題，盡量不會帶太多個人情緒在內，以供參考；個人資歷勉強算是一年而已，所以漏看了甚麼、或是回覆有些誤解還請各位多擔待。
開始前還是先推薦一篇文章。
 轉職軟體工程師可能沒有你想像中的那麼美好  本文 １、想學程式有沒有甚麼建議？ 大多數回覆我都會說如果「不排斥」的話，可以先找網路上的一些資源每天花一點時間看看，持續一段時間自己的感覺如何再來做決定。
回答「不排斥」這不是因為我不想多分享，就自身經驗來看我認為目前在這產業我僅能算是「不排斥」這份工作而從事而已；原因當然是因為進入業界後你會看到很多神人、甚至同事就有對程式癡迷的，大家都對程式有某些堅持，在這種環境我根本是小巫見大巫，說我喜歡程式&amp;hellip;嗯？
2、想從事你覺得適合嗎？ 這問題出現幾次我大概就會打太極幾次，也不是刻意，但畢竟是自己的人生嘛&amp;hellip;
好啦認真回覆。
首先如果是覺得原先工作辛苦、或是不如意想換換工作的人，我能給的建議就是 每份工作都有辛苦的地方 ，你和我覺得辛苦的尺度也不一樣，我不知道要怎麼以「客觀角度衡量主觀認定事實」後給予建議，所以 go big or go home？
3、工作內容、或是日常都在做甚麼？ 這可能會很常讓人誤解的是軟體工程師只要會寫程式就好，但以我自身經驗、看相關書籍、與朋友聊天得來的結果幾乎都是比起寫程式、更容易遇到要 與人溝通這件事；其實也不難理解，或是不難解釋這件事，畢竟程式寫出來就是給人用的，所以日常就是需要解決人的問題。
所以我認為除了寫程式的基本能力以外、「溝通」會是佔滿大一部分的日常工作。
4、是不是一直要學習新東西？ 是、沒錯、YES，就是你想的那樣。
不管是你主動、或是被動要求這件事都是肯定會發生的，身邊朋友或是大神隨便一個都是家裡有整櫃技術類書籍的，不然你以為我很閒沒事寫這些文章？沒事看書？
5、待遇如何？ 這問題承上，首先起薪比一般工作高是事實，之後就是這工作吸引人的地方了，一切都看實力說話，會持續學習東西、看新技術，有一部分就是因為薪水漲幅是可預見的。
6、工作環境？ 還是得先提醒一下，每間公司不同，我只能以我所看見的來分享。
如果要看精彩的歡迎點選右邊這連結 靠北工程師。
我很幸運的是目前工作的環境還不錯，工時正常、同事願意互相討論、上級也很願意協助解決問題；算是滿樂於互相分享、幫助的環境，這也與我一開始看到軟體工程師良好氛圍這件事一樣，套句公司大神跟我說的：「我們公司比上不足，比下有餘。」
但有些朋友待的公司可能就不大相同、加班常態，工作內容強硬等都是有所耳聞的，還是上面那句，要看精彩的請去靠北工程師。
7、職涯？ 年齡的確是工程師的硬傷，甚至矽谷也有很多傳聞35歲以上工程師就不太有人要了；但就我來看其實也不然全是這樣，之前看過一本書寫到「做一件事十年，跟認真做一件事十年是不一樣的。」
在職場的價值是需要靠個人耕耘跟規劃的，說不準到底會發生甚麼事，還是老話一句，你自己走走看就知道了。
後記 步入職場也快滿一年了，一開始寫這些文章純粹就是朋友相約、大神鼓勵，決定要記錄學習歷程，幫助自己以後忘記好找答案、或是能在職場上傳達有自學能力這件事，也沒想過這些文章會這麼快對其他人有所幫助；最後還是要說畢竟才一年，可能還有很多沒看到的東西，所以這僅是我的淺見希望對各位思考這些問題時有所幫助。</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-6:Dependency Inversion Principle(DIP)依賴反轉原則</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-6_dependency-inversion-principledip-%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87/</link>
      <pubDate>Tue, 01 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-6_dependency-inversion-principledip-%E4%BE%9D%E8%B3%B4%E5%8F%8D%E8%BD%89%E5%8E%9F%E5%89%87/</guid>
      <description>本文 依賴反轉原則 Dependency Inversion Principle(DIP) 定義：
  1、高階模組不應該依賴於低階模組，兩者都該依賴抽象。
  2、抽象不應該依賴於具體實作方式，具體實作方式應該依賴抽象。 目標：解除物件與物間之間直接依賴的關係。
  舉例：傳統汽車在車子故障、或是想要更換零件時，需要選擇維修廠進行這個動作。
public class 汽車狀況 { public bool 更換電瓶() { return true; } } public class A汽車保養廠 { public int 電瓶價格() { return 50000; } } private static void Main(string[] args) { var 汽車 = new 汽車狀況(); //需要更換電瓶了  if (汽車.更換電瓶() == true) { var 汽車保養廠 = new A汽車保養廠(); Console.WriteLine($&amp;#34;電瓶價格:{汽車保養廠.電瓶價格()}&amp;#34;); } } 車主一看價格驚覺事情不太對勁，決定要更換一間汽車保養廠，此時程式就必須要跟著改變內容。
public class 汽車狀況 { public bool 更換電瓶() { return true; } } public class B汽車保養廠 { public int 電瓶價格() { return 5000; } } private static void Main(string[] args) { var 汽車 = new 汽車狀況(); //需要更換電瓶了  if (汽車.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-5:Liskov Substitution Principle(LSP) 里氏替換原則</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-5_liskov-substitution-principlelsp-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87/</link>
      <pubDate>Mon, 31 Aug 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-5_liskov-substitution-principlelsp-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8F%9B%E5%8E%9F%E5%89%87/</guid>
      <description>前言 此篇觀念也會延續之前幾篇，可以一同搭配觀看。
 1、Object Oriented物件導向-3:封裝(Encapsulation)、繼承(Inheritance)與多型(polymorphism) 2、Object Oriented物件導向-4:抽象類別(Abstract)與介面(Interface)  本文 里氏替換原則 Liskov Substitution Principle(LSP) 精神：
 使用父類的地方，必須可以使用子類別代替，而不需要任何改變。
 基本原則：
 1、子類別必須完全實現父類別的方法，如果子類不擁有父類的全部屬性或者行為，不能強行繼承，要斷掉繼承。 2、子類別可以擁有自己不同的屬性與方法。  來段範例：今天我們有個傳統車廠發現電動車似乎才是未來，也想透過自己以前的經驗來設計電動車，老闆說不就都是車嘛？
public class 車子 { public int 車輪 = 4; public int 方向盤 = 1; public string 引擎() { return &amp;#34;汽油引擎&amp;#34;; } public string 後照鏡() { return &amp;#34;左右後視鏡+駕駛座後視鏡&amp;#34;; } } //直接繼承車子  public class 電動車 : 車子 { } private static void Main(string[] args) { var 汽車 = new 車子(); Console.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-4:Interface Segregation Principle(ISP) 介面隔離原則</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/</link>
      <pubDate>Tue, 25 Aug 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-4_interface-segregation-principleisp-%E4%BB%8B%E9%9D%A2%E9%9A%94%E9%9B%A2%E5%8E%9F%E5%89%87/</guid>
      <description>前言 這篇開始前可以先搭配前面的介面、內聚、耦合一同觀看。
 1、Object Oriented物件導向-4:抽象類別(Abstract)與介面(Interface) 2、Object Oriented物件導向-5:內聚(Cohesion)、耦合(Coupling)  本文 介面隔離原則 Interface Segregation Principle(ISP) 最重要的精神：
 不應該強迫用戶去依賴他們未使用的方法。
意及應該要最小化類別與類別之間的介面。
 基本原則：
 1、interface功能盡量少：達到一個介面只服務一個子模組/商業邏輯。 但有可能會與單一職責原則有衝突，比如已經拆成最仔細但功能還是很多，此時要以單一職責原則為優先。 2、不應該強迫實作沒用到的方法。  舉例：今天我們有個車子的設計圖，我們可以用來設計車子，於是我們創造了特斯拉以及Gogoro。
public interface 車子 { public string 引擎(); public string 後照鏡(); public string 車門(); } public class 特斯拉 : 車子 { public string 引擎() { return &amp;#34;3秒內時速100公里的引擎&amp;#34;; } public string 後照鏡() { return &amp;#34;左右後視鏡+駕駛座後視鏡+電腦雷達感應周邊&amp;#34;; } public string 車門() { return &amp;#34;側開敞篷車門&amp;#34;; } } public class Gogoro : 車子 { public string 引擎() { return &amp;#34;5秒內時速100公里的引擎&amp;#34;; } public string 後照鏡() { return &amp;#34;左右後視鏡&amp;#34;; } public string 車門() { return &amp;#34;痾沒有車門&amp;#34;; } } private static void Main(string[] args) { var 特斯拉 = new 特斯拉(); Console.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-3:Law of Demeter(LoD) 狄米特法則</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-3_law-of-demeterlod-%E7%8B%84%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87/</link>
      <pubDate>Mon, 24 Aug 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-3_law-of-demeterlod-%E7%8B%84%E7%B1%B3%E7%89%B9%E6%B3%95%E5%89%87/</guid>
      <description>本文 狄米特法則 Law of Demeter(LoD) 又稱為 最少知識原則 Least Knowledge Principle(LKP)
定義
 一個object應該對其他object有最少的瞭解。
 優點
 1、可以降低類別與類別之間的耦合度。 2、當耦合度降低的時候，類別的重用性就會提高。   2020/08/25 更新範例
舉例：前面例子我們知道特斯拉都是透過軟體的更新來讓車子增加新功能的，今天我們需要特斯拉有招喚模式，讓特斯拉能夠自己開到我們所在的位子；所以我們建造一個特斯拉類別裡面有更新系統的動作。
public class 特斯拉 { public string 啟動更新系統() { return &amp;#34;系統更新啟動&amp;#34;; } public string 加入特斯拉招喚模式() { return &amp;#34;新增招喚模式中&amp;#34;; } public string 系統更新結果() { return &amp;#34;系統更新成功&amp;#34;; } } private static void Main(string[] args) { var 特斯拉 = new 特斯拉(); Console.WriteLine(特斯拉.啟動更新系統()); Console.WriteLine(特斯拉.加入特斯拉招喚模式()); Console.WriteLine(特斯拉.系統更新結果()); } 對使用者來說他並不需要知道特斯拉是如何更新系統的，他應該只需要知道進行更新系統的動作，特斯拉會新增招喚模式；所以程式就能改寫如下。
public class 特斯拉 { public string 更新(string 更新項目) { return $&amp;#34;更新開始 : 新增{更新項目}完畢&amp;#34;; } } private static void Main(string[] args) { var 特斯拉 = new 特斯拉(); Console.</description>
    </item>
    
    <item>
      <title>Puppeteer Sharp網頁截圖轉成pdf</title>
      <link>https://sunnyday0932.github.io/2020/puppeteer-sharp%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf/</link>
      <pubDate>Tue, 04 Aug 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/puppeteer-sharp%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf/</guid>
      <description>前言 你聽過隕石開發法嗎？
沒聽過？那你可以看看轉載好文:隕石開發法
甚麼？你問隕石開發法跟這篇文有甚麼關係？
因為神有了需求 本文 上次有提到Puppeteer Sharp這個套件、以及黑大這篇文C# 整合 Headless Chrome 的好工具 - Puppeteer Sharp，但因為我的chromium版本一直無法運行就此作罷；直到主管突然提起同單位有人成功使用這個套件實作出功能。
 這時候別人用了同工具可以，沒道理我不行的心就蠢蠢欲動了。  把問題倒回碰到的起始點，是chromium無法運行，想想應該是套件抓下來的版本有問題，於是我研究了一下chromuim的版本，官方文件在此，發現版本其實分很多種，有開發版、測試版、穩定版，於是研究了一下就到此網址下載了官方提供版本更換套件內抓取的chromium測試。
1、 先到專案資料夾底下bin &amp;gt; Debugger &amp;gt; .local-chromium 內。 2、將下載版本複製貼上並取代此資料夾內檔案。 3、進行測試。
static void Main(string[] args) { Test().Wait(); } static async Task Test() { try { await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultRevision); using (var browser = await Puppeteer.LaunchAsync(new LaunchOptions() { Headless = true //偵測時可設定false觀察網頁顯示結果(註：非Headless時不能匯出PDF)  })) { using (var page = await browser.NewPageAsync()) { await page.GoToAsync(&amp;#34;https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/&amp;#34;); Thread.Sleep(1000); await page.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-2:Open-Close Principle(OCP) 開放封閉原則</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-2_open-close-principleocp-%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87/</link>
      <pubDate>Thu, 30 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-2_open-close-principleocp-%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87/</guid>
      <description>本文 開放封閉原則 Open-Close Principle(OCP) 定義
 軟體設計原則，應該對擴展開放，對修改封閉。
 甚麼意思呢？
 1、對擴展開放 - 程式碼對於新增功能是透過新增程式碼進行。 2、對修改封閉 - 新增功能時不應該是更改現有程式碼。  那為甚麼要使用OCP？
 1、程式碼可維護性提高。 2、程式碼可擴展性提高。 3、程式碼可複用、靈活性高。 4、程式碼可測試性提高。  2020/09/08更新
寫完這篇跟同事討論過後決定要更改，一直發懶就放到現在，被迫要在進入下階段前先把前面要改的改完。
現在回頭看覺得當初為啥寫這例子怪怪的，回想起來才發現，原來我是為了避免使用到DI的觀念啊，但後來看了其他人寫的文章，用DI好像比較容易敘述這個概念&amp;hellip;
所以就頭都要洗了，就先挖個坑吧。
我們來看一段例子，傳統汽車對於軟體硬體整合，還不夠靈活的時候，需要更改東西就需要把整台汽車拆開某些部分增加功能、每一次更改都是一項大工程。
public class 影音撥放器 { public string 安裝() { return &amp;#34;安裝影音撥放器成功&amp;#34;; } } public class 自動導航裝置 { public string 安裝() { return &amp;#34;安裝自動導航裝置成功&amp;#34;; } } public class 汽車 { public string 安裝影音撥放器() { var 影音波放器 = new 影音撥放器(); return 影音波放器.安裝(); } public string 安裝自動導航裝置() { var 自動導航裝置 = new 自動導航裝置(); return 自動導航裝置.</description>
    </item>
    
    <item>
      <title>網頁截圖轉成pdf檔(純屬好玩)</title>
      <link>https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/</link>
      <pubDate>Thu, 23 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/</guid>
      <description>前言 昨天接到一個新需求，需要用Url連結到其他網頁將該頁面截圖後，轉換成pdf檔供使用者下載。
今天研究了一下覺得好玩紀錄一下。
本文 接到需求後一開始是用 .NET Webpage to pdf當關鍵字搜尋，無奈找了幾個套件不是要收費就是已經年代久遠，最後用中文搜尋到了黑大去年寫的一篇文章。
C# 整合 Headless Chrome 的好工具 - Puppeteer Sharp
此篇是用Puppeteer Sharp這個套件將網頁截圖後儲存，套件資訊可以自行參閱。
Puppeteer Sharp是使用Chromium幫你截圖網站頁面，所以其實後背後運作 .NET還是有幫你開啟網頁的。
無奈今天嘗試後遇到 Failed to launch chrome 錯誤。
Google後發現很多人都有遇到類似問題，有很多人發issue給作者。
最後決定回頭繼續搜尋其他方式，這時候發現黑大今年又寫了另一篇文章。
C# 網頁轉圖檔 WebAPI - 青春版
這方法使用的是原生System.Web.Forms.WebBrowser方式擷取網頁圖片，一樣的 .NET有幫你開啟網頁進行截圖的動作，只是這個原生的方式就是使用IE。
測試的此方式可行後我就開始尋找第二步動作，該怎麼把圖檔轉換成pdf，於是找到了另一個套件iTextSharp。
可以套過套件將圖檔直接轉換成pdf的強大方法。
將黑大的方法結合iTextSharp就能得到想到的結果如下&amp;hellip;
private static void Main(string[] args) { string url = null; var png = WebSnapTool.Snapshot(url ?? &amp;#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/&amp;#34;, delaySecs: 0); using (var stream = File.Create(@&amp;#34;D:\test\test.pdf&amp;#34;)) using (var doc = new Document()) using (var pdfWriter = PdfWriter.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向設計原則SOLID-1:Single Responsibility Principle(SRP) 單一職責</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/</link>
      <pubDate>Tue, 21 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/</guid>
      <description>本文 OOP原則了解完後，我們知道程式設計應該朝向『高內聚、低耦合』的概念設計，那怎麼設計呢？
這時候了解設計原則SOLID就很重要了&amp;hellip;
1、Single Responsibility Principle(SRP) 單一職責  大話設計模式：就一個類別而言，應該只有一個引起它變化的原因。  什麼意思呢？概念上就是，一個類別就只專注於完成一件事。
為甚麼要只專注於做一件事呢?
我們來看看範例，當今天特斯拉的駕駛走投無路需要賺外快的時候，他需要上路招攬客人&amp;hellip;
//產生一個駕駛類別要有開車、招攬客人、計算車資的功能。  public class 駕駛 { public string 開車() { return &amp;#34;開車上路&amp;#34;; } public string 招攬客人() { return &amp;#34;有沒有人需要搭車&amp;#34;; } public int 計算車資(int 搭車人數) { var 今天電價 = 30; var 每位乘客搭乘價格 = this.關注電價(今天電價); return 搭車人數 * 每位乘客搭乘價格; } public int 關注電價(int 每度時價) { if (每度時價 &amp;gt; 50) { return 20; } return 10; } } private static void Main(string[] args) { 駕駛 特斯拉駕駛 = new 駕駛(); Console.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向-5:內聚(Cohesion)、耦合(Coupling)</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-5_%E5%85%A7%E8%81%9Acohesion%E8%80%A6%E5%90%88coupling/</link>
      <pubDate>Thu, 16 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-5_%E5%85%A7%E8%81%9Acohesion%E8%80%A6%E5%90%88coupling/</guid>
      <description>本文 1、內聚(Cohesion)  把功能所需要的資料與程式都塞在某一個模組(fuction、class、package)中，使得該模組成為一個單獨的可執行個體。  大意上就是把程式跟所需要的資料全部都包在一起。
舉例：(不要懷疑我們最熟悉的特斯拉又來了)
今天我想要讓特斯拉具備螢幕、音響這些娛樂設施可以看電影，有了電影當然需要食物啊，那就需要有在特斯拉上吃爆米花的功能。
//產生一個特斯拉類別有螢幕、音響、吃爆米花  public class 特斯拉 { public string 螢幕() { return &amp;#34;播放電影&amp;#34;; } public string 音響() { return &amp;#34;杜比環繞音效&amp;#34;; } public string 吃爆米花() { return &amp;#34;爆米花好吃&amp;#34;; } } private static void Main(string[] args) { 特斯拉 Tesla = new 特斯拉(); Console.WriteLine(&amp;#34;特斯拉 :&amp;#34; + Tesla.螢幕()); Console.WriteLine(&amp;#34;特斯拉開啟 :&amp;#34; + Tesla.音響()); Console.WriteLine(Tesla.吃爆米花()); } 這時候要提到程式設計常聽到的。
高內聚  高內聚力的好處就是提高了模組的『獨立性』，也就是說這個模組可以被單獨使用，也可以被單獨修改。  那應該怎麼做呢？
 思考模組的關聯性。  以我們剛剛舉的例子特斯拉具備螢幕、音響這些娛樂設備是合理的，但吃爆米花的動作是不是在這個Class中顯得有點怪異了呢？
 特斯拉本身並不需要知道怎麼吃爆米花，需要知道怎麼吃爆米花的是人。  我們修改一下範例</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向-4:抽象類別(Abstract)與介面(Interface)</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-4_%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5abstract%E8%88%87%E4%BB%8B%E9%9D%A2interface/</link>
      <pubDate>Tue, 14 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-4_%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5abstract%E8%88%87%E4%BB%8B%E9%9D%A2interface/</guid>
      <description>本文 1、抽象類別(Abstract)  1、抽象類別不能實體化。 2、抽象方法是用來給子類別重寫的方法，如果不重寫的話，抽象方法就沒有存在的意義。 3、如果類別中包含抽象方法，那麼整個類別就必須定義為抽象類別，不論是否還包含其他一般方法。  那麼甚麼時候該用到抽象類別呢？
大話設計模式：「當實體化沒有任何意義的父類別，就可以考慮改成抽象類別。」
敘述的還是有點難理解，那我們用個例子來說明。 在前幾篇的內容我們都用到了特斯拉這個例子，我們今天就延用。
//產生一個車子的類別，定義了啟動以及消耗能源  public abstract class 車子 { public abstract string 消耗能源(); public abstract string 啟動(); } //產生一個特斯拉類別繼承車子  public class 特斯拉 : 車子 { public override string 啟動() { return &amp;#34;特斯拉啟動&amp;#34;; } public override string 消耗能源() { return &amp;#34;消耗電能&amp;#34;; } } //產生一個汽車類別繼承車子  public class 汽車 : 車子 { public override string 啟動() { return &amp;#34;汽車啟動&amp;#34;; } public override string 消耗能源() { return &amp;#34;消耗汽油&amp;#34;; } } private static void Main(string[] args) { 汽車 car = new 汽車(); Console.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向-3:封裝(Encapsulation)、繼承(Inheritance)與多型(polymorphism)</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/</link>
      <pubDate>Wed, 08 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-3_%E5%B0%81%E8%A3%9Dencapsulation%E7%B9%BC%E6%89%BFinheritance%E8%88%87%E5%A4%9A%E5%9E%8Bpolymorphism/</guid>
      <description>本文 1、封裝(Encapsulation)  大話設計模式：每個物件都包含它進行操作所需要的所有資訊，這個特性稱為封裝，因此物件不必依賴其他物件來完成自己的操作。 封裝的優點 一、良好的封裝能夠減少耦合。 二、類別內部的實現可以自由地修改，並不會影響使用者。 三、類別具有清晰的對外界面。  這麼說封裝好像有點抽象，拿現實生活中的舉例就是：
當我們按下鍵盤A的時候，螢幕上會顯示A，但我們不必知道電腦背後是怎麼運作，就可以使用它。
程式的舉例： 個人寫程式到目前以來最常使用的C#判斷式，用來檢查字串是否為空。
var test= &amp;#34;This is string&amp;#34;; //一個測試用字串 string.IsNullOrEmpty(test); //檢查字串是否為Null或是空 //我們不必知道IsNullOrEmpty這個方法是如何實作的， //但我們知道它會幫我們判斷字串是否為Null或是空，並回傳true or false。 2、繼承(Inheritance) 以下取自大話設計模式：
 物件的繼承代表了一種&amp;quot;is-a&amp;quot;的關係，如果兩個物件A和B，可以描述為『B是A』，則表明了B可以繼承A。Ex:特斯拉是車子、貓是哺乳類動物。 繼承者可以理解為對被繼承者的特殊化，因為他除了具備繼承者的特性外，還具備自己獨有的個性。Ex：特斯拉消耗能源是靠電能相較於傳統汽車使用汽油、貓擁有爬高爬樹等能力將較於傳統哺乳類動物沒有的技能。 繼承定義了類別如何相互關聯共用特性。 子類別不但繼承父類別所有特性，還可以定義新的特性。   如果子類別繼承於父類別：
 一、子類別擁有父類別非private的屬性和功能。 二、子類別具有自己的屬性和功能 =&amp;gt; 子類別可以擴展父類別的所有特性。 三、子類別還可以用自己的方式實現父類別 =&amp;gt; 方法重寫。  //產生一個汽車的類別，有一個方向盤、四個輪子。 public class 汽車 { protected int 輪子 = 4; protected int 方向盤 = 1; } //產生一個特斯拉類別繼承汽車 public class 特斯拉 : 汽車 { public string 特斯拉輪子() { return &amp;#34;特斯拉有&amp;#34; + 輪子 + &amp;#34;個輪子&amp;#34;; } public string 特斯拉方向盤() { return &amp;#34;特斯拉有&amp;#34; + 方向盤 + &amp;#34;個方向盤&amp;#34;; } } private static void Main(string[] args) { 特斯拉 Tesla = new 特斯拉(); Console.</description>
    </item>
    
    <item>
      <title>閱讀心得:Grit恆毅力</title>
      <link>https://sunnyday0932.github.io/2020/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97_grit%E6%81%86%E6%AF%85%E5%8A%9B/</link>
      <pubDate>Wed, 01 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97_grit%E6%81%86%E6%AF%85%E5%8A%9B/</guid>
      <description>前言 恆毅力這本書是大約一年前，在無意間晃到作者TED演講影片發現的(有興趣可以到此連結觀看)。 影片內容提到恆毅力，作者的敘述是．．．
 恆毅力是面對長遠目標時的熱情和毅力。 恆毅力是有耐力的表現。 恆毅力是日復一日依然對未來堅決不已，不只是這週、不只這個月，而是年復一年。 用心、努力工作來實現所堅信的那個未來。 恆毅力是將生活看作是一場馬拉松，不是短跑。   當時正值研究所考試失利，反覆思考很多問題，又想著要如何解決當前困境；看到這段敘述馬上就買了，但諷刺的是到現在才看完。
本文 這本書內容大致上都圍繞在成長型思維這個概念中，認為學習能力不是一成不變的，它會由於你的努力而產生變化。
提到努力大概會覺得很抽象，對於成功這兩個詞亦是。 所以作者作為一名心理學家，把她對於恆毅力研究對象分享出來，以下列舉幾個比較有印象的。
 西點軍校新生。 頂尖運動選手Ex:世界盃足球賽隊伍。 拼字比賽選手。   研究目的是要知道這些所謂人家口中的成功者，他們是如何成功的？ 西點軍校，不比其他頂尖大學還難進入，相關報導可參閱，作者想知道在西點軍校這麼高壓的環境下，最後能撐到畢業的是哪些人？
世界盃足球賽，每年都有頂尖隊伍參與競爭，各隊都有頂尖的運動選手，最後會勝出的隊伍到底具備哪些能力？
拼字比賽選手，參與拚字比賽的選手，每天都要透過閱讀字典去認識一堆生詞，更多的是很長的字，最後獲得勝利的選手，他們到底跟其他人有甚麼不一樣？
那麼要如何培養恆毅力呢？  由內而外:自己培養興趣；養成習慣，每天作挑戰自己能力的練習；設定超越自我的目標；受到挫折不放棄希望。 由外而內:週遭的人也是影響培養恆毅力的關鍵，家長、教練、老師、老闆、導師、朋友都可以成為助力。 培養跌倒七次，要爬起來八次的力量。  關於失敗這件事，請用失敗重新定義成功。 幾年前也看過類似文章，可口可樂、網飛、亞馬遜如何以失敗為師，現在看起來很成功的公司，他們企業文化是如何讓員工願意去嘗試。
最後恆毅力並不是唯一 恆毅力只是作者研究出來結果的一種統稱，我的解讀是恆毅力是一種精神，它並不是一個人唯一的一種面向；Amazon創辦人貝佐斯也提過類似概念，他說過小時候因為外婆吸菸過量，計算外婆如果依照這個速度只能活到幾歲而把外婆惹哭的故事，他說:「聰明是一種天賦，而善良一種選擇；天賦得來很容易，而選擇則頗為不易。」
後記 一年前買這本書大概看了一半就放到現在，最近重新拿起讀完又有不同心境；當時研究所重考兩次失利打擊真的滿大，一直在想到底哪裡做得不好，也是偶然間看到無限賽局這個思考方式。
 無限賽局中，真正的競爭對手其實不是別人，而是我們自己；真正的目標是讓自己（無論組織或個人）今年變得比去年更好。  相較於舊的賽局理論，無限賽局認為單次的輸贏並不重要，而是透過長遠的規劃，未來會在某一時刻逆轉賽局。
現在有了更完善的人生規劃，希望能藉由吸收這些不同的知識，讓自己能持續成長，在未來某個時刻去到自己想去的地方。
參考連結  恆毅力：人生成功的究極能力。  </description>
    </item>
    
    <item>
      <title>Json格式轉換，序列化(Serialize)與反序列化(Deserialize)</title>
      <link>https://sunnyday0932.github.io/2020/json%E6%A0%BC%E5%BC%8F%E8%BD%89%E6%8F%9B%E5%BA%8F%E5%88%97%E5%8C%96serialize%E8%88%87%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96deserialize/</link>
      <pubDate>Tue, 30 Jun 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/json%E6%A0%BC%E5%BC%8F%E8%BD%89%E6%8F%9B%E5%BA%8F%E5%88%97%E5%8C%96serialize%E8%88%87%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96deserialize/</guid>
      <description>前言 今天在工作上剛好碰到了要將字串轉換成Json格式傳遞給別人，遇到了有趣的事情特別記錄一下。
本文 一開始很好奇我擷取的字串出來序列化的Json格式，會多出空行的符號\r\n。
&amp;#34;{\&amp;#34;A\&amp;#34;:\&amp;#34;ss\r\nss\&amp;#34;,\&amp;#34;B\&amp;#34;:\&amp;#34;ss\nss\&amp;#34;}&amp;#34; 於是就跟同事討論起這件事，我一開始想法是這是不是會影響別人收到後處理結果呢?
同事做了簡單範例解釋。
class Program { static void Main(string[] args) { var objTest = new Test { A = &amp;#34;ss\r\nss&amp;#34;, B = &amp;#34;ss\nss&amp;#34; }; var jsonObj = JsonConvert.SerializeObject(objTest); Console.WriteLine(jsonObj); var obj2 = JsonConvert.DeserializeObject&amp;lt;Test&amp;gt;(&amp;#34;{\&amp;#34;A\&amp;#34;:\&amp;#34;ss\r\nss\&amp;#34;,\&amp;#34;B\&amp;#34;:\&amp;#34;ss\nss\&amp;#34;}&amp;#34;); Console.WriteLine(obj2.A); Console.WriteLine(obj2.B); } public class Test { public string A { get; set; } public string B { get; set; } } } 輸出結果
Json格式會有自己特殊的跳脫字元，而在反序列化中程式就會將字串轉換成我們看到的正常樣貌。
所以結論就是，通通丟給對方處理就對了🤟
參考連結  1、Json官方文件 2、瞭解Json格式  </description>
    </item>
    
    <item>
      <title>Object Oriented物件導向-2:建構式(Constructor)、多載(Overloading)與覆寫(Overriding)</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-2_%E5%BB%BA%E6%A7%8B%E5%BC%8Fconstructor%E5%A4%9A%E8%BC%89overloading%E8%88%87%E8%A6%86%E5%AF%ABoverriding/</link>
      <pubDate>Tue, 23 Jun 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-2_%E5%BB%BA%E6%A7%8B%E5%BC%8Fconstructor%E5%A4%9A%E8%BC%89overloading%E8%88%87%E8%A6%86%E5%AF%ABoverriding/</guid>
      <description>本文 1、建構式(Constructor)
 實體化類別的動作，也就是New這個步驟。 建構式與類別同名，無return值。 大話設計模式：其實就是對類別進行初始化。建構式與類別同名，無返回值，也不需要void，在New時調用。  Public class 特斯拉() { private 輪子(){} private 方向盤(){} private 電池(){} } 特斯拉 車子 = new 特斯拉(); //這樣我們就可以得到一輛車子並且知道車子具有輪子、方向盤、電池 2、多載(Overloading)
 相同function名稱，可以有不同參數或不同的型別。 大話設計模式：多載提供了建立同名的多個方法的能力，但這些方法須使用不同的參數類型。
2020/06/30 修改範例  //首先建立一個特斯拉的類別。 Public class 特斯拉 { public void 配件() //預設基本配件有輪子、方向盤、電池。 	{ private 輪子(){} private 方向盤(){} private 電池(){} } public void 配件(int 加購價 ) //加購價的配件會有更高級的配備。 	{ private 跑車輪子(){} private 跑車方向盤(){} private 高電量電池(){} } } 特斯拉 ModelX = new 特斯拉(); ModelX.</description>
    </item>
    
    <item>
      <title>Object Oriented物件導向-1:類別(Class)與實體(Object)</title>
      <link>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-1_%E9%A1%9E%E5%88%A5class%E8%88%87%E5%AF%A6%E9%AB%94object/</link>
      <pubDate>Mon, 22 Jun 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-1_%E9%A1%9E%E5%88%A5class%E8%88%87%E5%AF%A6%E9%AB%94object/</guid>
      <description>前言 這系列文會整理進目前公司以來所學，目標是釐清自己觀念、脫離只知其一不知其二的狀態，故文章將會不停更新。
本文 1、類別(class)
 在程式設計中類別就像設計圖、它描繪出設計出來的樣貌。 大話設計模式：類別就是具有相同之屬性和功能的物件抽象集合。 Ex:汽車設計圖、建築物設計圖。
  2、物件(Object)
 實際設計出來的物品。 大話設計模式：物件是一個獨立自主的實體，用一組可識別的特性和行為來標示。 Ex:特斯拉汽車、101大樓。
  3、實體化
 描繪類別變成實體物件的狀態。 Ex:C#程式中會使用New來實體化出一個物件。  class 車子 { private 輪子(){} private 電池(){} private 方向盤(){} } 車子 特斯拉 = new 車子() 問題討論 這邊的問題取自保哥物件導向基礎，建議往下看前先自行思考作答。
 1、請問「類別」可不可以包含「物件」？ 2、請問「物件」可不可以包含「類別」？ 3、請問「類別」可不可以包含「類別」？ 4、請問「物件」可不可以包含「物件」？ 5、請問「物件」可不可以當成資料傳遞？ 6、請問「類別」可不可以當成資料傳遞？ 7、 在 .NET 的世界，請問「物件」可以用什麼型態存在或用什麼格式傳遞？（可任意回答一種以上） 8、在 .NET 的世界，請問「類別」可以用什麼型態存在或用什麼格式傳遞？（可任意回答一種以上） 9、在 .NET 的世界，程式在執行的時候，「類別」可不可以被動態修改？ 10、如果有兩台主機要互相傳遞資料，他們傳遞的是「類別」還是「物件」？ 11、請問「物件」是否包含「方法(Method)」？ 12、如果「物件」從 A 電腦傳遞到 B 電腦時，若該物件要執行「方法」還需不需要有「類別」存在？
   作答
1、不可以。本題提供同事講解易懂方式 Ex:特斯拉設計圖內不會包含真的特斯拉。
2、不可以。物件是實體的東西、而類別再被new出來前都是虛擬的，故實體物件不應該包含虛擬類別。</description>
    </item>
    
    <item>
      <title>閱讀心得:Soft Skills 軟實力｜軟體開發人員的生存手冊</title>
      <link>https://sunnyday0932.github.io/2020/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97_soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/</link>
      <pubDate>Mon, 01 Jun 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97_soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/</guid>
      <description>前言 這是踏入職場後第一本挑選的書，起因是公司教育訓練文件最後前輩列了一系列書單，其中名字最特別、歸類又不是技術類，看了試閱的第一頁就決定買了。
本文  目錄
 序:這是一本你從未見過的軟體開發書 Section 1 職涯 Section 2 自我行銷 Section 3 學習 Section 4 生產力 Section 5 理財 Section 6 健身 Section 7 心靈
目錄應該很明顯，這真的是從未見過專門寫給軟體開發人員的密技；玩遊戲都會都看密技了，職涯看一下應該也很合理。
這本書就是把踏入這行會發生的全部過程拆解，細分後再加以分析利弊整理出一些可供參考的方式。
拿第一章職涯作為舉例，當談到如何設立職涯目標的時候作者會先敘述自己的經驗並給出一些建議，再來教你如何設定出真正可以執行的目標(不會好高騖遠)，最後會給出練習的方式。
照著每一小節的練習，確實可以有助於自己思考與規劃。
最特別的大概是最後三章:理財、健身、心靈。
這部分作者就跳脫出職業生活的部分，提醒的是儘管開發人員有多熱愛自己的工作，下了班你還是會回歸日常。
而這部分就是針對日常生活給出的建議。
其中健身這章可以拉出來特別提一下，因為本身也開始健身兩年了，這本書對於健身觀念真的非常正確，不管是計算卡路里方式、制定健身課表、飲食全方位講解都很透徹。
作者也提到，因為職涯長時間坐著對開發人員真的是一大傷害；運動不僅能帶給職涯很多正面的幫助，要想達成目標，擁有健康的身體亦是必要條件，這也是我開始健身的初衷之一。   後記  這本書大概是一月入手，當時因為教育訓練落後狀態低迷，沒有想太多就是想趕快進步，看完也五個月過去了，這中間斷斷續續的閱讀、但堅持每個小節的即知即行都要自己做一遍，真的對我幫助不小；包含了現在決定開始經營部落格，有一部分原因也是因為看了這本書。
強烈建議軟體開發人員有機會都可以看看這本書，真的會對你職涯規劃有所幫助，但當然作者與我們生活環境落差，有些經驗並不適用於每個人，不能照單全收，這也是需要自行判斷，最後就像書中所述step by step有一天一定能達到自己目標的。</description>
    </item>
    
    <item>
      <title>SQL FOR XML合併欄位顯示 SUBSTRING擷取字串</title>
      <link>https://sunnyday0932.github.io/2020/sql-for-xml%E5%90%88%E4%BD%B5%E6%AC%84%E4%BD%8D%E9%A1%AF%E7%A4%BA-substring%E6%93%B7%E5%8F%96%E5%AD%97%E4%B8%B2/</link>
      <pubDate>Fri, 29 May 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/sql-for-xml%E5%90%88%E4%BD%B5%E6%AC%84%E4%BD%8D%E9%A1%AF%E7%A4%BA-substring%E6%93%B7%E5%8F%96%E5%AD%97%E4%B8%B2/</guid>
      <description>前言 前陣子工作上需求，需要做匯出報表功能，要將不同欄位資料合併再一起後匯出，順手記錄一下。
本文 示範資料表如下
我們需要把相同Level的欄位匯總再一起，做成一個統計用報表。
首先每個區域後面先加、
select District+&#39;、&#39; from DistrictData 接下來使用
select level, ( select District+&#39;、&#39; from DistrictData as B where A.Level = B.Level FOR XML PATH(&#39;&#39;) )AS District FROM DistrictData AS A GROUP BY level 即可得到想要的成果。
其中FOR XML PATH(&#39;&#39;)功能是因為如果沒有加的話會出現以下錯誤訊息。
接下來會發現顯示格式不太對，要加上、的部分最後一筆應該要排除。
這時候就可以使用SUBSTRING
select SUBSTRING(&#39;大安區、信義區、松山區、中山區、中正區、&#39;,0,LEN(&#39;大安區、信義區、松山區、中山區、中正區、&#39;)) 可以得到以下。
SUBSTRING這個語法中SUBSTRING(string, start, lenth)，第1、2個參數代表的是string這個字串中要起始的位置為start，lenth則為最後要計算數字。
簡單實驗一下
select SUBSTRING(&#39;123&#39;,0,3) 這邊我們會得到
參考資料 https://www.1keydata.com/tw/sql/sql-substring.html
https://dotblogs.com.tw/flairming/2014/02/14/143993
https://dotblogs.com.tw/supershowwei/2016/01/26/145353</description>
    </item>
    
    <item>
      <title>Hugo加入留言、觀看人數</title>
      <link>https://sunnyday0932.github.io/2020/hugo%E5%8A%A0%E5%85%A5%E7%95%99%E8%A8%80%E8%A7%80%E7%9C%8B%E4%BA%BA%E6%95%B8/</link>
      <pubDate>Sun, 24 May 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/hugo%E5%8A%A0%E5%85%A5%E7%95%99%E8%A8%80%E8%A7%80%E7%9C%8B%E4%BA%BA%E6%95%B8/</guid>
      <description>前言 開始使用Hugo後，對於目前使用的主題Leaveit不盡滿意，於是開始研究修改，改完又想在現在版型加上其他功能EX:觀看人數、留言功能，Google搜尋後有很多種方法，選了自己順眼的就開始動工，內容如下。
本文 一、留言功能 留言功能有很多方式，最後決定選用DISQUS，原本還有另一套utteranc，但&amp;hellip;DISQUS看起來較為順眼、再加上留言方式多元於是雀屏中選(?
對沒什麼高尚理由，單純就是覺得好看。
1、先到DISQUS註冊帳號。
2、註冊完後會到以下畫面，選擇下方選項 I want to install Disqus on my site。
(小提醒註冊完後記得先到信箱點選註冊確認信)
3、輸入website名稱，選擇Category分類，點選建立。
4、接下來會到選擇方案頁面，點選下方Basic版本(此為免費版)。
5、接著install頁面，會發現選項內並沒有HUGO，但不打緊，DISQUS提供自行手動設定，步驟稍後說明。
6、最後config設定，加入網站URL註冊步驟就完成了。
接下來就可以開始設定留言功能到我們的HUGO網站。
7、 開啟 Config.toml 加入下方參數。
disqusShortname = &amp;quot;你在DISQUS註冊時輸入的Website name&amp;quot; 8、接著在目錄/layouts/partials/內新增一個disqus.html檔案，官方提供的內容如下。 這邊需要注意的是，如果你是有使用主題，會需要移至主題底下目錄此路經新增。
&amp;lt;div id=&amp;quot;disqus_thread&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; (function() { // Don&#39;t ever inject Disqus on localhost--it creates unwanted // discussions from &#39;localhost:1313&#39; on your Disqus account... if (window.location.hostname == &amp;quot;localhost&amp;quot;) return; var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true; var disqus_shortname = &#39;{{ .</description>
    </item>
    
    <item>
      <title>Hugo架站教學</title>
      <link>https://sunnyday0932.github.io/2020/hugo%E6%9E%B6%E7%AB%99%E6%95%99%E5%AD%B8/</link>
      <pubDate>Sun, 10 May 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/hugo%E6%9E%B6%E7%AB%99%E6%95%99%E5%AD%B8/</guid>
      <description>前言 受到前輩、夥伴、朋友的激勵，決定開始記錄自己學習過程。
這次在架站花了過多時間在調畫面，最後還是沒到自己滿意狀態；但花的時間過久，決定先生出第一篇文章之後再來調剩下的東西。
希望不會就此停留在現在模板😂
本文 這次選擇Hugo主要是因為朋友推薦、中文資源夠多，再加上主題豐富，於是自己花時間摸索一下也覺得不難就決定選用Hugo。
一、環境變數設定 1、首先到Hugo官方提供下載點將相對應個別系統的安裝包下載下來。
2、將下載下來安裝包解壓縮後會得到以下檔案。
3、將hugo.exe檔案複製或剪下至C:\
4、設定系統環境變數，路徑:控制台&amp;gt;系統及安全性&amp;gt;系統&amp;gt;進階系統設定。
5、選擇系統環境設定。
6、系統變數Path點選編輯。
7、新增系統變數，這邊因為我將hugo.exe放在C巢跟目錄底下因此設定為C:\。
8、接下來回到C:\使用CMD測試hugo，輸入hugo version，只要出現以下畫面就代表環境設定完成。
 二、架設方式 1、使用CMD輸入hugo new site &amp;ldquo;你要放資料夾的位子&amp;rdquo;。
2、hugo會自動建立預設資料夾。
然後就可以套用自己想要的主題到themes這個資料架內，主題可以到以下連結選擇。
3、套用主題，在themes資料夾使用CMD輸入git clone &amp;ldquo;你想要的主題&amp;rdquo;。
4、順利下載就會出現許多新資料夾。
5、接下來就是修改內容改成自己想要的樣子就算完成了。
 三、預覽方式 1、在資料夾使用CMD輸入hugo server -v。
 這裡要注意的是因為我們將hugo放在C:\，因此要啟用server時要將路徑給上。   2、接下來只要用瀏覽器輸入http://localhost:1313/就可以看到自己的網站了。
 四、部屬方式 1、首先到Github建立兩個Repository，一個隨便、另一個要為&amp;rsquo;你的帳號&#39;.github.io。
2、在hugo存放自己blog的資料夾下建立public，並連結GitHub上自己的Repository。
git submodule add -f https://github.com/sunnyday0932/sunnyday0932.github.io.git public3、在資料夾使用CMD輸入C:\hugo執行建立內容到public，成功的話在public內會出現以下資料夾。
4、將public 內檔案 commit and push 到&amp;rsquo;你的帳號&#39;.github.io。
5、回到存放blog的資料夾內，連結git上存放blog的Repository。
git remote add origin https://github.com/sunnyday0932/hugo_blog.git6、commit and push 到github上。
7、接下來只要輸入https://&amp;lsquo;你的帳號&amp;rsquo;.github.io/即可預覽網站。
五、參考連結 https://carrie-lai.github.io/post/createhugoblog/
https://raychiutw.github.io/2019/Hugo-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8/</description>
    </item>
    
  </channel>
</rss>
