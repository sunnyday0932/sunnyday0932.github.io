<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp on Sian</title>
    <link>https://sunnyday0932.github.io/tags/csharp/</link>
    <description>Recent content in csharp on Sian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 30 Apr 2021 01:40:45 +0000</lastBuildDate><atom:link href="https://sunnyday0932.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WebApi 加入快取 - 1</title>
      <link>https://sunnyday0932.github.io/2021/webapi-%E5%8A%A0%E5%85%A5%E5%BF%AB%E5%8F%96-1/</link>
      <pubDate>Fri, 30 Apr 2021 01:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/webapi-%E5%8A%A0%E5%85%A5%E5%BF%AB%E5%8F%96-1/</guid>
      <description>前言 延續上次我們使用Hangfire排程抓取Youbike的練習題，這次我們要做一個Youbike的Service，專門提供查詢Youbike相關站點資訊的服務；前面製作排程的時候有提到因為Youbike站點資訊一分鐘才會更新一次，為了加快程式的查詢效率我們就可以將查詢的資料做成快取一分鐘在此期間加快查詢的效能。
本文 快取的使用時機 當API效能遇到瓶頸的時候，就可以使用快取來減少不必要去DB撈取資料的動作，最常使用的會是記憶體快取、Redis快取等。
快取的適用時機 一般使用快取的功能通常是資料的變動性不大、不太會被變更的資料。
當然當某些特殊情境的情況下也可以使用快取Ex:購物節的時候電商網站等，那這種情況下就需要考慮到快取資料與我們DB資料同步的問題。
快取的注意事項 使用快取的方式簡單來說是用錢換取時間(記憶體比起硬碟貴了許多)，通常在放資料進快取的時候會需要注意資料的大小、能不能適度地進行切分，以及存放的過期時間，而不是拿了就丟全部放入快取內(當然如果你本多忠勝不在此限)。
開始前準備 這邊基本的API就不再進行示範，我們現在簡單的提供兩個功能，一個是查詢全部Youbike站點的功能、另一個是查詢指定Youbike站點的功能。
先看一下初始的Repository結構。
/// &amp;lt;summary&amp;gt; /// 取得全部Youbike站點 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public async Task&amp;lt;IEnumerable&amp;lt;StationDataModel&amp;gt;&amp;gt; GetAllStationAsync() { var sql = @&amp;quot;SELECT [StationNo] ,[StationName] ,[Total] ,[BikeAmount] ,[StationArea] ,[ModifyDate] ,[Latitude] ,[Longitude] ,[Address] ,[StationAreaEnglish] ,[StationNameEnglish] ,[AddressEnglish] ,[Available] ,[Active] ,[SrcUpdateTime] ,[UpdateTime] ,[InfoTime] ,[InfoDate] FROM [Northwind].[dbo].[YoubikeStation]&amp;quot;; using (var conn = this._databaseHelper.GetConnection(this._connectionString)) { var result = await conn.QueryAsync&amp;lt;StationDataModel&amp;gt;(sql); return result; } } /// &amp;lt;summary&amp;gt; /// 取得指定Youbike站點 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;stationNo&amp;quot;&amp;gt;The station no.</description>
    </item>
    
    <item>
      <title>CoreProfiler - 監看WebApi效能的工具</title>
      <link>https://sunnyday0932.github.io/2021/coreprofiler-%E7%9B%A3%E7%9C%8Bwebapi%E6%95%88%E8%83%BD%E7%9A%84%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 29 Apr 2021 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/coreprofiler-%E7%9B%A3%E7%9C%8Bwebapi%E6%95%88%E8%83%BD%E7%9A%84%E5%B7%A5%E5%85%B7/</guid>
      <description>前言 接下來會用到CoreProfiler這個工具來觀看我們API的效能，就花一點時間紀錄一下用法。
本文 CorePofiler這個工具是提供給Core版本的效能工具，也有給dotnet framework的版本NanoProfiler。
用到的Nuget  CoreProfiler.Web 安裝在Application。 CoreProfiler 安裝在Application跟要監看的類別庫。  使用方式 1、在我們需要監看的地方加上以下程式。
var stepName = $&amp;quot;{nameof(這邊是監看的類別)}.{nameof(這邊是監看的方法)}&amp;quot;; using (ProfilingSession.Current.Step(stepName)) { } 2、在Service與Repository的地方都加上。
Service：
Repository：
3、若要監看與DB存取資料的狀況，可以到DatabaseHelper這麼做。
/// &amp;lt;summary&amp;gt; /// 建立連線 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public IDbConnection GetConnection(string connectionString) { var conn = new ProfiledDbConnection ( new SqlConnection(connectionString), () =&amp;gt; ProfilingSession.Current is null ? null : new DbProfiler(ProfilingSession.Current.Profiler) ); return conn; } 4、CoreProfiler的設定，可以建立一個coreprofiler.json的檔案。
{ //資料保存上限 &amp;quot;circularBufferSize&amp;quot;: 200, //要過濾掉的項目 &amp;quot;filters&amp;quot;: [ { &amp;quot;key&amp;quot;: &amp;quot;/coreprofiler&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;/coreprofiler&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;CoreProfiler.</description>
    </item>
    
    <item>
      <title>dotnet Core HangFire - Youbike練習題</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-youbike%E7%B7%B4%E7%BF%92%E9%A1%8C/</link>
      <pubDate>Mon, 12 Apr 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-youbike%E7%B7%B4%E7%BF%92%E9%A1%8C/</guid>
      <description>前言 前面介紹完Hangfire後，這邊是個人製作簡易練習題，所以不會有太多敘述，比較偏向個人筆記。
內文 1、目標。  使用Youbike2.0政府開放資料。 每分鐘去抓取資料後寫回DB。  2、實作。 使用API網址為：Youbike2.0政府開放資料。。
使用說明：
觀察一下API格式。
建立Model存放。
public class YoubikeDataModel { /// &amp;lt;summary&amp;gt; /// 站點代號 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;sno&amp;quot;)] public string StationNo { get; set; } /// &amp;lt;summary&amp;gt; /// 場站中文名稱 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;sna&amp;quot;)] public string StationName { get; set; } /// &amp;lt;summary&amp;gt; /// 場站總停車格 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;tot&amp;quot;)] public int Total { get; set; } /// &amp;lt;summary&amp;gt; /// 場站目前車輛數量 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;sbi&amp;quot;)] public int BikeAmount { get; set; } /// &amp;lt;summary&amp;gt; /// 場站區域 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;sarea&amp;quot;)] public string StaionArea { get; set; } /// &amp;lt;summary&amp;gt; /// 資料更新時間 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;mday&amp;quot;)] public DateTime ModifyDate { get; set; } /// &amp;lt;summary&amp;gt; /// 緯度 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;lat&amp;quot;)] public double Latitude { get; set; } /// &amp;lt;summary&amp;gt; /// 經度 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;lng&amp;quot;)] public double Longitude { get; set; } /// &amp;lt;summary&amp;gt; /// 地點 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;ar&amp;quot;)] public string Address { get; set; } /// &amp;lt;summary&amp;gt; /// 場站區域英文 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;sareaen&amp;quot;)] public string StationAreaEnglish { get; set; } /// &amp;lt;summary&amp;gt; /// 場站名稱英文 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;snaen&amp;quot;)] public string StationNameEnglish { get; set; } /// &amp;lt;summary&amp;gt; /// 地址英文 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;aren&amp;quot;)] public string AddressEnglish { get; set; } /// &amp;lt;summary&amp;gt; /// 空位數量 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;bemp&amp;quot;)] public int Available { get; set; } /// &amp;lt;summary&amp;gt; /// 全站禁用狀態 /// &amp;lt;/summary&amp;gt; [JsonProperty(&amp;quot;act&amp;quot;)] public string Active { get; set; } /// &amp;lt;summary&amp;gt; /// source update time.</description>
    </item>
    
    <item>
      <title>dotnet Core HangFire - 4(使用技巧與設定下篇)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E8%88%87%E8%A8%AD%E5%AE%9A%E4%B8%8B%E7%AF%87/</link>
      <pubDate>Mon, 05 Apr 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E8%88%87%E8%A8%AD%E5%AE%9A%E4%B8%8B%E7%AF%87/</guid>
      <description>本文 1、Trigger(觸發程序)。 看到這裡，我一開始以為所謂的Trigger就只有類似於在SQL Server當觸動某張Table時，會觸發某種事件這樣，但其實並不只是只有此種才稱之為Trigger，所以一開始看到大神介紹此種方法的時候還一頭霧水。
我們可以將排程做成Trigger的方式，由程式啟動的時候觸發部屬排程工作。
順便會帶一點將排程執行的邏輯拆程類似之前分層架構的模式。
首先我們建立一個ITimeService介面、與實作就是取得當下時間。
public interface ITimeService { public DateTime GetCurrentTime(); } public class TimeService : ITimeService { public DateTime GetCurrentTime() { var currentTime = DateTime.Now; return currentTime; } } 接下來建立一個HangfireJob的介面與類別，這邊實體就會使用到剛剛所建立的TimeService。
public interface IHangfireJob { void GetCurrentTime(); } public class HangfireJob : IHangfireJob { private readonly ITimeService _timeService; public HangfireJob( ITimeService timeService) { this._timeService = timeService; } public void GetCurrentTime() { var startTime = this._timeService.GetCurrentTime(); Console.WriteLine($&amp;quot;起始時間：{startTime.ToLocalTime():yyyy/MM/dd HH:mm:ss}&amp;quot;); Thread.</description>
    </item>
    
    <item>
      <title>dotnet Core HangFire - 3(使用技巧與設定上篇)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E8%88%87%E8%A8%AD%E5%AE%9A%E4%B8%8A%E7%AF%87/</link>
      <pubDate>Sat, 03 Apr 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E8%88%87%E8%A8%AD%E5%AE%9A%E4%B8%8A%E7%AF%87/</guid>
      <description>前言 本篇會介紹一些特殊使用技巧，跟一些可以調整的設定。
本文 1、API觸發排程。 首先建立一個API Controller。
[Route(&amp;quot;api/[controller]&amp;quot;)] [ApiController] public class HangfireApiController : ControllerBase { [Route(&amp;quot;enquee&amp;quot;)] [HttpGet] public string TestHangfire() { BackgroundJob.Enqueue( () =&amp;gt; Console.WriteLine(&amp;quot;API觸發：Fire and Foreget Schedule!&amp;quot;)); return &amp;quot;排程觸發&amp;quot;; } } 測試：
2、設定排程Priority。 先在StartUp中ConfigureService設定Priority。
services.AddHangfireServer(options =&amp;gt; { //priority options.Queues = new[] { &amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;default&amp;quot; }; }); 將Recurring Job 改成：
//Recurring job RecurringJob.AddOrUpdate ( recurringJobId: &amp;quot;Recurring job&amp;quot;, () =&amp;gt; Console.WriteLine($&amp;quot;Recurring job觸發時間：{DateTime.Now}&amp;quot;), cronExpression:&amp;quot;*/1 * * * *&amp;quot;, TimeZoneInfo.Local ); RecurringJob.AddOrUpdate ( recurringJobId: &amp;quot;alpha job&amp;quot;, () =&amp;gt; Console.</description>
    </item>
    
    <item>
      <title>dotnet Core HangFire - 2</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-2/</link>
      <pubDate>Thu, 01 Apr 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-2/</guid>
      <description>前言 接下來試做HangFire。
本文 1、前置步驟。 一樣選擇Web應用程式。
接下來要選擇MVC的架構。
安裝以下三個Nuget套件。
 Hangfire Hangfire.AspNetCore Newtonsoft.Json  在SSMS中localhost新建一個Hangfire DB。
2、設定。 把DB連線放在appsettings中加入connection string。
&amp;quot;ConnectionStrings&amp;quot;: { &amp;quot;HangFire&amp;quot;: &amp;quot;Server=localhost;Database=Hangfire;Trusted_Connection=True;&amp;quot; } StartUp加入設定。
public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews(); //Hangfire var hangfireConnection = this.Configuration.GetConnectionString(name:&amp;quot;Hangfire&amp;quot;); services.AddHangfire(config =&amp;gt; { config.UseSqlServerStorage( nameOrConnectionString: hangfireConnection, options: new SqlServerStorageOptions { SchemaName = &amp;quot;HangfireSample&amp;quot;, JobExpirationCheckInterval = TimeSpan.FromMinutes(value:60) }); }); services.AddHangfireServer(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(&amp;quot;/Home/Error&amp;quot;); // The default HSTS value is 30 days.</description>
    </item>
    
    <item>
      <title>dotnet Core HangFire - 1(排程工具)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-1%E6%8E%92%E7%A8%8B%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 28 Mar 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-hangfire-1%E6%8E%92%E7%A8%8B%E5%B7%A5%E5%85%B7/</guid>
      <description>前言 這次主題要來介紹排程，一般原生作法排程會直接寫一個Windows排程，而這種做法就是管理不易，所以後續就有一些開源專案來提供.NET製作排程，如：Quartz.Net、Coravel。
而這次主要會介紹HangFire。
本文 一、相關資源。 1、官方文件。
2、中文文件。
二、基本介紹。 A、特別注意的特性： HangFire在建構起來後就等同於一個網站，所以它也有著一般IIS會遇到的特性，就是網站若一段時間沒人訪問會進入睡眠狀態，一旦進入睡眠模式排程就有機會遺漏未執行。
像我們公司解法就是透過硬體，A10機器會定期訪問HangFire站台，確保站台是有在運行的。
B、HangFire優點：  Simple - 開發簡單、安裝簡易、部屬到站台也很方便。 Reliable - HangFire提供了排程失敗的自動重試機制。 Distributed - 可透過分散式處理消化大量工作。 Persistent - 任務可存放在多種儲存裝置中(如:SQLServer、Redis等)地方，不必擔心站台被回收後排程任務消失。 Transparent - 透明化的作業流程，HangFire提供了儀錶板可以即時的查看任務工作執行的狀態，同時也可以透過儀表板取消、或是執行排程任務。  C、三大核心元件。  HangFire Client - 主要建立後端排程任務(Ex:前面說的一個網站)。 Job Storage - 主要儲存排程任務(Ex:DB)。 HangFire Server - 主要處理排程任務的地方。  排程工作的完整流程：
 1、Client 建立一個排程任務。 2、排程任務儲存到Storage後，回傳一個JobId給Client。 3、Server端存Storage拿取要處理的排程任務。 4、Server端處理排程任務。  D、排程任務的類型。 1、Fire-and-forget Jobs - 這類型的Job進到排程佇列後會馬上執行且只會執行一次。
var jobId = BackgroundJob.Enqueue( () =&amp;gt; Console.WriteLine(&amp;quot;Fire-and-forget!&amp;quot;)); 2、Delayed jobs - 這類型的排程可以延遲執行。
var jobId = BackgroundJob.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi - 3(Unit-test)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-webapi-3unit-test/</link>
      <pubDate>Sat, 20 Mar 2021 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-webapi-3unit-test/</guid>
      <description>前言 接續上一篇，這篇主要是講解非同步的單元測試，同樣也只會列出不同的地方。
本文 1、Service Test。 傳入Model為空。
[TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;AddAccount&amp;quot;)] public async Task AddAccount_傳入Model為空_應回傳ArgumentNullException() { //assert var sut = this.GetSystemUnderTest(); //act var exception = await Assert.ThrowsExceptionAsync&amp;lt;ArgumentNullException&amp;gt;( async () =&amp;gt; await sut.AddAccount(null)); //arrange exception.Message.Contains(&amp;quot;不可為空&amp;quot;); } 結果：
某一個欄位為空。
[TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;AddAccount&amp;quot;)] public async Task AddAccount_Account為空_應回傳ArgumentException() { //assert var sut = this.GetSystemUnderTest(); var fixture = new Fixture(); var info = fixture.Build&amp;lt;AccountInfoModel&amp;gt;() .Without(x =&amp;gt; x.Account) .Create(); //act var exception = await Assert.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi - 2(第二層驗證、Paging)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-webapi-2%E7%AC%AC%E4%BA%8C%E5%B1%A4%E9%A9%97%E8%AD%89paging/</link>
      <pubDate>Tue, 16 Mar 2021 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-webapi-2%E7%AC%AC%E4%BA%8C%E5%B1%A4%E9%A9%97%E8%AD%89paging/</guid>
      <description>本文 1、第二層驗證(Service、Repository)。 上一篇我們介紹了Controller的驗證，接下來介紹Service、Repository層的驗證方式，大概會有疑惑為甚麼Controller驗證過了接下來兩層還需要驗證呢？
先前介紹過三層式架構的開發，其中也有提到其實三層是可以分開進行的，所以當然是也需要驗證。
驗證的方式會給Service與Repository使用，所以我們做成一個共用方法放在Common層，Service跟Repository再對Common加入參考使用。
Common層需要加入System.ComponentModel.Annotations Nuget套件。
驗證Model使用方法。
public class ModelValidator { /// &amp;lt;summary&amp;gt; /// Validates the specified model. /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;quot;T&amp;quot;&amp;gt;&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;quot;model&amp;quot;&amp;gt;The model.&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;quot;parameterName&amp;quot;&amp;gt;Name of the parameter.&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;quot;System.ArgumentNullException&amp;quot;&amp;gt;&amp;lt;/exception&amp;gt; /// &amp;lt;exception cref=&amp;quot;System.ArgumentException&amp;quot;&amp;gt;&amp;lt;/exception&amp;gt; public static void Validate&amp;lt;T&amp;gt;(T model, string parameterName) where T : class { if (model is null) { if (string.IsNullOrWhiteSpace(parameterName)) { parameterName = nameof(model); } throw new ArgumentNullException(paramName: parameterName, message: $&amp;quot;{parameterName}不可為空&amp;quot;); } var errors = new List&amp;lt;ValidationResult&amp;gt;(); var validation = Validator.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi - 1(非同步、FluentValidation驗證)</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-webapi-1%E9%9D%9E%E5%90%8C%E6%AD%A5fluentvalidation%E9%A9%97%E8%AD%89/</link>
      <pubDate>Mon, 15 Mar 2021 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-webapi-1%E9%9D%9E%E5%90%8C%E6%AD%A5fluentvalidation%E9%A9%97%E8%AD%89/</guid>
      <description>前言 介紹完非同步程式設計接下來就可以開始實作了，基本上大同小異，這次也只會著重在特別的地方說明，剩下的會把Code放在Github上，有需要的歡迎取用。
本文 1、appsettings。 之前介紹Core都沒有特別提到appsettings，其實它就是dotnet framework的config設定檔，可以透過不同的組態設定在不同的環境做切換，Ex:正式環境、測試環境。
這次我們把DB的連線字串放在appsettings內，透過startup的時候拿取所需的DB連接字串。
2021/04/19更新
感謝同事協助指正，appsettings並不完全等同於dotnet framework的Webconfig，而是core將原本全部擠在Webconfig的地方拆分歸類在不同地方，例如：Nuget套件就歸在csproj、appsettings區塊就是Core的appsettings。
那Core難道就完全不需要Webconfig了嗎？
倒也不是，像是我們公司的Core專案還是會加上Webconfig檔案，內容就主要做為設定CI建置的調整、或是對IIS的一些細部設定，還是可以透過Webconfig來做，可供大家使用上做參考。
{ &amp;quot;Logging&amp;quot;: { &amp;quot;LogLevel&amp;quot;: { &amp;quot;Default&amp;quot;: &amp;quot;Information&amp;quot;, &amp;quot;Microsoft&amp;quot;: &amp;quot;Warning&amp;quot;, &amp;quot;Microsoft.Hosting.Lifetime&amp;quot;: &amp;quot;Information&amp;quot; } }, &amp;quot;ConnectionString&amp;quot;: { &amp;quot;Northwind&amp;quot;: &amp;quot;Server=localhost;Database=Northwind;Trusted_Connection=True;&amp;quot; } } 在StartUp拿取connetcion。
/// &amp;lt;summary&amp;gt; /// 取得DB連線 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private string GetConnection(string databaseName) { var connection = this._configuration.GetValue&amp;lt;string&amp;gt;($&amp;quot;ConnectionString:{databaseName}&amp;quot;); return connection; } 完整StartUp。
public class Startup { /// &amp;lt;summary&amp;gt; /// Startup /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;configuration&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; public Startup(IConfiguration configuration) { this.</description>
    </item>
    
    <item>
      <title>非同步程式設計基礎介紹</title>
      <link>https://sunnyday0932.github.io/2021/%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Tue, 09 Mar 2021 16:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/</guid>
      <description>前言 先前我們介紹了API的基本用法，現在我們來介紹非同步的方法。
本文 首先還是要先提醒一下，對於非同步程式設計有很多眉眉角角，這邊只能簡單說明，所以若想更深入了解還是推薦大家尋求專業知識來源。
首推：
 MSDN使用 async 和 await 進行非同步程式設計。 .NET 本事－非同步程式設計。  一、同步與非同步。 1、同步。 我們先來認識一下甚麼叫做同步的程式設計。
其實你已經寫過了。
拿之前寫過的UpdataAccount Service來做說明，我們很明確會知道這段程式會由上到下一步一步接續執行，圖示意就是以下。
(圖片取自.NET 本事－非同步程式設計) 而這種同步程式設計有很明顯的問題。
 a、當有某項處理程序需要長時間的處理時，使用者與程式的互動體驗差，Ex:按下按鈕之後需要等到程式回應才會有其他動作。 b、當某個應用程式進入無窮迴圈導致其他應用程式暫停時，整個OS會像當機一樣，此時只能叫出工作管理員強制關閉程式、或是重開機。  當上述這些情況發生時當電腦只有一顆CPU可以執行Process，那就會很明顯的被Lock住。
而為了解決CPU無法分頭進行處理就有了新的執行續(Thread)概念。
2、Thread(執行續)。 這時候就可以把當年準備考試的筆記拿出來用一下了。
當年上課老師也比喻Thread就像是一台車裡面有幾個引擎的概念。
Thread 與 Process的差別。
   Process Thread     OS 分配資源的對象單位 OS分配CPU時間的對象單位   Process之間無共享的資源及記憶體(除了Shared memory溝通外) 同一個Process內的threads彼此共享此Process的記憶體與OS資源   Process的Ceation、Context Switching較慢，管理成本高。 Thread的較快、管理成本低。   Process內的Single-thread若Blocked，則整個Process也一起Blocked Process內只要有Thread還可以執行，則Process不會被Blocked   Multiprocessor架構之效益發揮較差。 較佳。   不需提供互斥存取機制(除了Shared memory溝通外) 必須對Threads共享的資源及Data，提供互斥存取，控制防止資料不正確等問題。   適用時機：一個時間只有一個Task執行時EX:Command interpreter、Linux Shell。 適用時機：一個時間有多個Task同時執行EX:Clent-Server架構的Server。    所以透過多個執行續的概念我們希望程式能夠達到這樣。</description>
    </item>
    
    <item>
      <title>單元測試 - 10工具介紹(查看涵蓋率、複雜度)</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-10%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%B4%B9%E6%9F%A5%E7%9C%8B%E6%B6%B5%E8%93%8B%E7%8E%87%E8%A4%87%E9%9B%9C%E5%BA%A6/</link>
      <pubDate>Sun, 07 Mar 2021 16:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-10%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%B4%B9%E6%9F%A5%E7%9C%8B%E6%B6%B5%E8%93%8B%E7%8E%87%E8%A4%87%E9%9B%9C%E5%BA%A6/</guid>
      <description>前言 前幾篇已經介紹完單元測試基本方法了，那這篇主要是介紹一些好用的工具，能夠透過工具檢視程式碼目前單元測試的涵蓋率、以及查看複雜度；透過這些數據來檢視自己的程式碼是否還能夠在更優化。
本文 1、Find Code Coverage。 原本是要介紹另一個測試方法，是使用Axocover；但在完成這幾篇的當下，馬上看到公司大神推薦了這個，現成的就拿來用啦XD，若有興趣的會把Axocover連結附在此。
Axocover For Visual Studio 2019。 
進入正題。
Find Code Coverage
首先我們先打開Visual Stdio Extension進行安裝。
下載完後安裝視窗跳出時記得先把VS關掉，不然會無法完成安裝。
接下來打開VS到檢視 &amp;gt; 其他視窗 &amp;gt; 點選Find Code Coverage打開視窗。
首次打開視窗會是空的，要先執行一次測試才會有東西。
再次打開就可以看到結果。
通常我們都會要求涵蓋率在95%以上，但當然各家公司實踐上有自己的標準，就可以依此來查看數據當作依據。
 小提醒 因為 Find Code Coverage 會在每一次測試時幫你去計算覆蓋率，等於一個測試會跑兩次，若不想每次重跑一遍可以到設定的地方關掉，再要看覆蓋率時再打開即可。
 設定方式：
打開 工具 &amp;gt; 選項。
找到 Find Code Coverage，把Run的選項Enable改成False即可。
2、CodeMaintainibility。 CodeMaintainibility
一樣要到Extension的地方搜尋安裝。
安裝完重新打開VS後會發現每一個方法都會出現一個旗子。
點選後會顯示一些指標，可以供看這段程式碼的複雜度等，以此作為依據方法是否需要拆分、優化等。
3、CodeMaid。 CodeMaid
一樣是到Extension搜尋後安裝。
安裝完後打開VS，要到延伸模組 &amp;gt; CodeMaid &amp;gt; Spade地方將儀表板打開。
打開後就可以看到現在該方法的程式碼複雜度。
滑鼠移過去就會顯示每一個Function。
後記 單元測試基本介紹就到這邊告一個尾聲，若有興趣可以自行研究TDD、BDD等實踐方式，以此相互搭配。
這些工具提供出來是想讓各位做為依據，通常在一段程式碼需要重構的時候都會先透過工具來觀察程式碼複雜度，接下來會先進行單元測試，讓單元測試作為一個防線，保證重構的過程不會把核心邏輯給改壞。
那麼單元測試就到此告一個段落。</description>
    </item>
    
    <item>
      <title>單元測試 - 9(Repository測試)</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-9repository%E6%B8%AC%E8%A9%A6/</link>
      <pubDate>Mon, 01 Mar 2021 20:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-9repository%E6%B8%AC%E8%A9%A6/</guid>
      <description>前言 前面介紹完Service層的測試方法，接續介紹Repository的測試。
本文 這邊先講解一下要如何進行Repository的測試，這層主要負責的部分都是與DB溝通進行資料面的處理，那當然我們單元測試不可能直接對正式DB直接做連結，要測試的話可以透過Container例如:docker、或是使用localDB進行整合測試，這邊主要是以localDB進行示範。
一樣先建立一個Repository的測試專案。
記得測試專案要加入原本Repository的參考。
使用SSMS取得建立Table的SQL語法。 將SQL檔案存放到測試專案內。
記得也要調整檔案屬性，為永遠複製。
使用SSMS取得INSERT DATA的SQL語法。 接下來就是一直下一步完成。
產出的檔案：
安裝Dapper到Repository測試專案。 因為測試SQL Command時會利用Dapper去執行SQL，所以需要安裝。
準備Repository測試使用到之方法。 1、DatabaseName。 public class DatabaseName { public const string Default = &amp;quot;master&amp;quot;; public const string SampleDB = &amp;quot;Northwind&amp;quot;; } 2、DatabaseCommands。 public class DatabaseCommands { /// &amp;lt;summary&amp;gt; /// 建立DB /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;connectionString&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;quot;database&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; public static void CreateDatabase( string connectionString, string database) { var IsExists = DatabaseExists(connectionString, database); if (IsExists) { return; } using var conn = new SqlConnection(connectionString); conn.</description>
    </item>
    
    <item>
      <title>單元測試 - 7</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-7/</link>
      <pubDate>Mon, 22 Feb 2021 20:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-7/</guid>
      <description>前言 接續完成我們API的單元測試，前面示範過的部分就不會再重複敘述，有比較特別的地方會特別提醒，那就開始吧。
本文 GetAccount(取得單筆帳號資訊) 1、輸入的Account不可為空。 [TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;GetAccount&amp;quot;)] public void GetAccount_Account為空_應回傳Exception() { //arrange var sut = this.GetSystemUnderTest(); //act Action actual = () =&amp;gt; sut.GetAccount(&amp;quot;&amp;quot;); //assert actual.Should().Throw&amp;lt;Exception&amp;gt;() .Which.Message.Contains(&amp;quot;Account 不可為空 !&amp;quot;); } 2、若查詢的Account有資料應回傳正確資訊。 [TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;GetAccount&amp;quot;)] public void GetAccount_Account有資料_應回傳正確資訊() { //arrange var data = new AccountDataModel() { Account = &amp;quot;test123&amp;quot;, CreateDate = DateTime.Now, ModifyDate = DateTime.Now, Email = &amp;quot;test123@gmail.com&amp;quot;, ModifyUser = &amp;quot;sys&amp;quot;, Phone = &amp;quot;0918777888&amp;quot; }; var sut = this.</description>
    </item>
    
    <item>
      <title>單元測試 - 8(CsvHelper、AutoFixture)</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-8csvhelperautofixture/</link>
      <pubDate>Mon, 22 Feb 2021 20:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-8csvhelperautofixture/</guid>
      <description>前言 本篇會介紹測試Service層好用工具，可以加快撰寫測試。
本文 CsvHelper 先前我們在測試方法時，遇到要取用資料都只能自己手刻。
這時候就可以使用一個好用的工具CsvHelper。
這邊主要是將資料庫的DATA匯出CSV檔，透過CsvHelper讀取資料，模擬Repository回傳資料給Service進行測試。
1、先將DB資料匯成CSV檔。 將我們要匯出的資料使用MSSQL SELECT出來。
對左上方空白的地方點選滑鼠右鍵，選擇儲存結果。
將檔案儲存到我們測試專案地方，建立一個TestData資料夾存放。
記得要到專案內，將要測試的CSV檔案屬性改成永遠複製。
2、安裝Nuget 套件。 3、修改測試方法。 首先在測試Class加上一個Attribute。
[DeploymentItem(@&amp;quot;TestData\AccountData.csv&amp;quot;)] 接著我們就可以在要使用的地方這麼做。
[TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;GetAccount&amp;quot;)] public void GetAccount_Account有資料_應回傳正確資訊使用CSV測試() { //arrange var sourceData = new List&amp;lt;AccountDataModel&amp;gt;(); using (var sr = new StreamReader(@&amp;quot;AccountData.csv&amp;quot;)) using (var reader = new CsvReader(sr, CultureInfo.InvariantCulture)) { var records = reader.GetRecords&amp;lt;AccountDataModel&amp;gt;(); sourceData.AddRange(records); } var sut = this.GetSystemUnderTest(); this._accountRepository.GetAccount(&amp;quot;test2&amp;quot;).Returns(sourceData.FirstOrDefault(x =&amp;gt; x.Account == &amp;quot;test2&amp;quot;)); var expect = this._mapper.Map&amp;lt;AccountDto&amp;gt;(sourceData.FirstOrDefault(x =&amp;gt; x.Account == &amp;quot;test2&amp;quot;)); expect.</description>
    </item>
    
    <item>
      <title>單元測試 - 6</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-6/</link>
      <pubDate>Wed, 17 Feb 2021 20:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-6/</guid>
      <description>前言 我們已經介紹了基本寫單元測試的方法，接下來我們就可以回頭拿先前製作的API當作練習，補上該有的測試。
本文 首先我們建立一個放置測試專案的資料夾。
接著建立完測試專案。
 2021/02/21更新 原本是只想開一個測試專案把Repository跟Service的測試都放在一起後來想想不太對。 更新後的專案結構如下。
 因為是要對Service層進行測試，記得要加入專案參考。
接下來先把基礎測試專案需要用到的東西準備好。
[TestClass] public class AccountServiceTest { private IAccountRepository _accountRepository; private IMapper _mapper { get { var config = new MapperConfiguration(options =&amp;gt; { options.AddProfile&amp;lt;ServiceProfile&amp;gt;(); }); return config.CreateMapper(); } } [TestInitialize] public void TestInitialize() { this._accountRepository = Substitute.For&amp;lt;IAccountRepository&amp;gt;(); } private AccountService GetSystemUnderTest() { var sut = new AccountService(this._accountRepository,this._mapper); return sut; } [TestMethod] public void TestMethod1() { } } 這邊需要特別注意的地方在AutoMapper的地方，我們並不需要製作一個假的AutoMapper，所以可以直接使用原本方法。
接下來就可以開始寫單元測試了。
AddAccount(新增帳號) 1、有四個必填欄位需要確認。 [TestMethod] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;AccountServiceTest&amp;quot;)] [TestProperty(&amp;quot;AccountServiceTest&amp;quot;, &amp;quot;AddAccount&amp;quot;)] public void AddAccount_Account為空_應回傳Exception() { //assert var sut = this.</description>
    </item>
    
    <item>
      <title>單元測試 - 5(NSubstitute介紹)</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-5nsubstitute%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Fri, 05 Feb 2021 20:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-5nsubstitute%E4%BB%8B%E7%B4%B9/</guid>
      <description>前言 上一篇提到了NSubstitute，前輩看到後提點了一些用法，順勢研究完多一篇筆記紀錄一下(絕對不是我原本想要跳過不介紹被抓到才補上這篇)。
本文 驗證互動是否符合預期方法 接續上次使用範例。
情境:
我們現在有一個Check的方法，若出現錯誤則會紀錄一筆log。
首先先把log方法準備好。
public interface ILog { void SaveLog(string message); } public class Log : ILog { public void SaveLog(string message) { Console.WriteLine(message); } } Check 方法。
bool Check(string text); public bool Check(string text) { if (string.IsNullOrWhiteSpace(text)) { this._log.SaveLog(&amp;quot;text 不可為空!&amp;quot;); return false; } return true; } 接下來我們先調整一下我們的測試方法。
private ILog _log; private IRepository _repository; [TestInitialize] public void TestInitialize() { this._log = Substitute.For&amp;lt;ILog&amp;gt;(); this._repository = Substitute.For&amp;lt;IRepository&amp;gt;(); } private Service GetSystemUnderTest() { var sut = new Service(this.</description>
    </item>
    
    <item>
      <title>單元測試 - 4</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-4/</link>
      <pubDate>Mon, 01 Feb 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-4/</guid>
      <description>本文 初始化與清除使用的Attribute 上一篇我們介紹到使用改變時間的用法，但因為其中一個測試改變了時間可能會影響到其他單元測試，這時候就有幾個Attribute可以派上用場。
   Attribute 用法 頻率     TestInitialize() 在執行每一項測試之前，會先執行TestInitialize的程式碼。 每執行一個TestMethod會觸發一次。   TestCleanup() 在執行每一項測試之後，會執行TestCleanup的程式碼。 每執行一個TestMethod會觸發一次。   ClassInitialize() 在執行該類別的測試之前，會先執行ClassInitialize的程式碼。 以測試類別為單位執行一次。   ClassCleanup() 在執行該類別的測試之後，會執行ClassCleanup的程式碼。 以測試類別為單位執行一次。   AssemblyInitialize() 在執行所有類別的測試之前，會先執行AssemblyInitialize的程式碼。 以測試專案為單位執行一次。   AssemblyCleanup() 在執行該類別的測試之後，會執行AssemblyCleanup的程式碼。 以測試專案為單位執行一次。    練習:
如題為了避免我們改變時間進而影響到其他單元測試，我們在執行每一個測試前後都會初始化一次時間。
[TestInitialize] public void TestInitial() { SystemTime.SetToday = () =&amp;gt; DateTime.Today; } [TestCleanup] public void TestClean() { SystemTime.SetToday = () =&amp;gt; DateTime.Today; } 隔離物件 測試的時候我們會需要隔離要測試的物件，如果直接相依物件會產生一些不必要的問題導致測試結果可能有誤。</description>
    </item>
    
    <item>
      <title>單元測試 - 3</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-3/</link>
      <pubDate>Sat, 30 Jan 2021 18:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-3/</guid>
      <description>本文 比對兩個物件方式 首先我們建立一個測試用Model。
public class TestModel { public string UserName { get; set; } public string Account { get; set; } } 建立一個測試方法驗證兩個物件是否相同。
[TestMethod()] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;Class1&amp;quot;)] [TestProperty(&amp;quot;Class1&amp;quot;, &amp;quot;Object&amp;quot;)] public void ObjectTest_比較兩個相同物件_應回傳正確結果() { //arrange var fistObject = new TestModel { Account = &amp;quot;abc&amp;quot;, UserName = &amp;quot;Sian&amp;quot; }; var secondObject = new TestModel { Account = &amp;quot;abc&amp;quot;, UserName = &amp;quot;Sian&amp;quot; }; secondObject.Should().Be(fistObject); } 結果 有點奇怪，我們換回內建的方法測試看看。
[TestMethod()] [Owner(&amp;quot;Sian&amp;quot;)] [TestCategory(&amp;quot;Class1&amp;quot;)] [TestProperty(&amp;quot;Class1&amp;quot;, &amp;quot;Object&amp;quot;)] public void ObjectTest_比較兩個相同物件_應回傳正確結果() { //arrange var fistObject = new TestModel { Account = &amp;quot;abc&amp;quot;, UserName = &amp;quot;Sian&amp;quot; }; var secondObject = new TestModel { Account = &amp;quot;abc&amp;quot;, UserName = &amp;quot;Sian&amp;quot; }; //secondObject.</description>
    </item>
    
    <item>
      <title>單元測試 - 2</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-2/</link>
      <pubDate>Fri, 29 Jan 2021 13:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-2/</guid>
      <description>本文 單元測試方法命名 單元測試的藝術內簡單得規範出一種一目了然的命名方式。
分為三個部分：
   名稱 解釋     1、UunitOfWorkName(單元測試名稱) 被測試的方法、一組方法或一組類別。   2、Scenario(情境) 要測試的情境，例如:傳入NULL、傳入字串。   3、ExpectedBehavior(預期的行為) 在測試情境指定的條件下，我們對測試結果的預期    單元測試名稱_情境_預期的行為，三個組成就是一個完整的句子。
接著我們就可以修改一下前次練習的測試方法名稱。
常用到的Attribute 接下來介紹幾個比較常用到的Attribute：
   Attribute 用途     [TestMethod] 表示這是一個測試方法。   [OwnerName] 此測試方法的建立者。   [TestCategory] 測試的方法在哪個類別。   [TestProperty] 表示該方法是在哪個類別內的測試方法。   [Ignore] 驗證測試時會忽略該方法。   [ExpectedException] 驗證例外處理的Attribute。    用法示範：
[TestMethod()] //這是一個測試方法 [Owner(&amp;quot;Sian&amp;quot;)] //此方法由Sian建立 [TestCategory(&amp;quot;Class1&amp;quot;)] //此測試方法在Class1這個類別 [TestProperty(&amp;quot;Class1&amp;quot;, &amp;quot;GetUserName&amp;quot;)] //此測試方法是Class1類別內的GetUserName public void GetUserName_輸入的UserName為空值_應回傳提示訊息() { //arrange var target = new Class1(); var name = string.</description>
    </item>
    
    <item>
      <title>單元測試 - 1</title>
      <link>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-1/</link>
      <pubDate>Wed, 27 Jan 2021 13:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-1/</guid>
      <description>前言 API講解完後接下來我們來介紹能夠快速驗證自己程式邏輯的好用工具-單元測試(Unit-Test)，實務上也有使用單元測試的開發方法，如:TDD(Teat-Driven Development)測試驅動開發；接下來介紹內容會以單元測試的藝術以及公司大神提供文件所學介紹，最後會以完成先前開發API單元測試為目標。
內文 單元測試 單元測試的藝術對一個優秀單元測試的定義為：
一個單元測試是一段自動化的程式碼，這段程式會呼叫被測試的工作單元， 之後對這個單元的單一最終結果的某些假設或期望進行驗證。 單元測試幾乎都是使用單元測試框架進行撰寫的。 撰寫單元測試很容易，執行起來快速。 單元測試可靠、易讀、並且很容易維護。 只要產品程式碼不發生變化，單元測試的執行結果是穩定一致的。 該具備的特性有：
   特性 定義     1、Fast(快速) 每一個單元測試執行的速度夠快。 通常單一個單元測試要在毫秒之內完成。   2、Independent(獨立性) 不能與外部資源相依。外部物件有：資料庫、服務、其他單元測試等。   3、Repeatable(可重複) 單元測試要是可以重複執行的，其結果不會因為執行次數而改變。   4、Self-Validating(可反應驗證結果) 單元測試執行的結果，不論成功或失敗都要能從測試報告內清楚明瞭原因。   5、Timely(及時) 單元測試應該要在產品測試碼完成的當下就能驗證執行結果是否符合預期。    單元測試的3A原則:    原則     1、Arrange : 初始化目標物件、相依物件、方法參數、預期結果，或是預期與相依物件的互動方式。   2、Act : 呼叫目標物件的方法。   3、Assert : 驗證是否符合預期。    整合測試 接下來介紹一下可能會混淆的整合測試。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi - EFCore</title>
      <link>https://sunnyday0932.github.io/2021/dotnet-core-webapi-efcore/</link>
      <pubDate>Fri, 22 Jan 2021 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/dotnet-core-webapi-efcore/</guid>
      <description>前言 前面我們已經練習過使用Dapper，剛好前輩提起EF也是需要練習熟悉的，就做了一個EF Core的版本，基本上內容與先前API 第二版本大致相同，這邊就只會列出差異部分與碰到的問題。
本文 一、首先我們會需要先安裝三個EF需要使用到的Nuget 套件。 分別是：
   Nuget名稱 安裝地點     EntityFrameworkCore Repository   EntityFrameworkCore.SqlServer Repository   EntityFrameworkCore.Tools Controller    二、接下來需要輸入指令建立EFCore所使用的DBContext。 完整指令如下：
Scaffold-DbContext &#39;Data Source=localhost;Database=Northwind;Trusted_Connection=True;&#39; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Conditions -Tables Users -context AccountContext -Project WebApiEFCoreRepository -force 這邊提一下指令由前到後介紹：
Scaffold-DbContext &#39;Data Source=localhost;Database=Northwind;Trusted_Connection=True;&#39; Microsoft.EntityFrameworkCore.SqlServer 這段是我們與DB連線字串，然後指定所使用的DB是SQL server。
-OutputDir Conditions 這邊是生成檔案放置地點。
-Tables Users 指定的Table名稱。
-context AccountContext 這是會生成的DBContext檔案名稱，這邊我取名為AccountContext。
-Project WebApiEFCoreRepository -force 指定生成在Repository專案，最後的force其實第一次生成DBContext時不用加，但後續要再加Table的時候可能會用上；至於我為甚麼留著呢？那當然是因為 懶惰
三、建完之後步驟。 指令建出來的context檔案其中有一段DB連線的地方這邊可以先拿掉，之後我們會使用注入的方式拿取連線字串。
接下來建立IAccountRepository
public interface IAccountRepository { /// &amp;lt;summary&amp;gt; /// 取得單筆帳號資訊 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;account&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public AccountCondition GetAccount(string account); /// &amp;lt;summary&amp;gt; /// 取得帳號列表 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public IEnumerable&amp;lt;AccountCondition&amp;gt; GetAccountList(); /// &amp;lt;summary&amp;gt; /// 新增帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;condition&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool AddAccount(AccountCondition condition); /// &amp;lt;summary&amp;gt; /// 刪除帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;account&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool RemoveAccount(string account); /// &amp;lt;summary&amp;gt; /// 更新帳號資訊 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;condition&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool UpdateAccount(AccountCondition condition); /// &amp;lt;summary&amp;gt; /// 忘記密碼 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;condition&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool ForgetPassword(AccountCondition condition); } 實作AccountRepository</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 4</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-4/</link>
      <pubDate>Sat, 26 Dec 2020 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-4/</guid>
      <description>前言 API第二階段告一段了，此篇整理一下這次所做API會需要注意的事項。
本文 1、API驗證欄位。 在這次API會看到在新增、更新、刪除資料時，第一件事都會檢查欄位是否有缺少，這邊也是我剛開始寫API常會遺忘的事情，之前也常被前輩叮嚀；現在完成的API架構屬於前、後端分離，首先我們不能預設前端會是哪些Ex:網頁、Android、Ios等，當然也不能預設串接API那一方一定會依照我們所開的規格輸入。
 簡單來說：『製作API時，你永遠不能相信你的前端。』  (希望我的前端不會看到這一篇&amp;hellip;)
回歸重點，這裡不是要大家去前、後端對立(請不要劃錯重點XD)，而是要有預備心態，當今天API路徑被其他人知道、或是前端頁面因為某些原因漏傳了幾個參數，此時可能會造成資料庫形成髒資料、或是被刪除了某些必要資料。
 在製作API時前輩也叮嚀過，自己做出來的API就是死命用不同的方式打掛他測試就對了。  或是可以跟別人交換測試API，自己測有盲點別人幫你測很快就會找到問題。
當然最好的方式是使用單元測試、或是有QA團隊幫忙監控產品品質，但畢竟大家所處環境不同，不是哪裡都有QA團隊、或是時間趕根本沒時間給你寫單元測試(我沒有在暗指&amp;hellip;)，在此當作提醒分享給大家。
2、錯誤訊息處理。 這次我的作法當欄位有缺少時是直接throw new exception，大家都有不同的做法，個人傾向當欄位缺少這種比較顯而易見的就是直接讓他報錯；那如果是ㄧ些沒被發現的錯誤、或是要記Log這種，我們公司目前的做法是使用Nlog搭配Exceptionless做紀錄。
3、Dapper寫法。 這次Repository使用Dapper時會看到有以下這種寫法。
var parameters = new DynamicParameters(); parameters.Add(&amp;quot;@Password&amp;quot;, condition.Password, DbType.String); parameters.Add(&amp;quot;@Account&amp;quot;, condition.Account,DbType.String); 在加入變數給Dapper時預先給了DbType，這是之前在看前輩的Code時發現他會這樣寫，細問之下才知道原來Dapper在未指定欄位的型態時，它會用猜的來決定變數型態，因此會大大影響執行效能，所以後來使用Dapper都會順手加上欄位對應的型態。
若想詳細知道內容可參考這篇： Dapper 用起來很友善，但是預設的參數型別對執行計劃不太友善。
4、正則表達式。 這次檢查信箱是否合法寫法是&amp;hellip;
private bool CheckMailFormate(string email) { try { var mail = new MailAddress(email); return true; } catch { return false; } } 這是剛好看到原來.NET有提供這種檢查方式，平常我們的做法可能是會使用正則表達式，它能夠更細部的規範到底可以輸入哪些字元。
有興趣的可以參考以下： .NET 規則運算式
總結 剛開始寫程式很容易進入一種走火入魔階段，一開始就想要寫得很好，思考半天卻甚麼都沒寫出來、或是參考別人程式後複製貼上，根本也不知道為甚麼別人這樣寫。
這邊一開始也是受到滿多前輩的幫助，大致上可以概括成：
 先求有，再求好。  例如：看到別人寫了一串很潮的Lambda語法一行就解決了，但根本也不知道他在做甚麼；其實就可以退回到最原始的寫法，先使用For迴圈或是Foreach，完成後再來思考怎麼改進自己的程式、或是詢問別人為甚麼這樣寫。
以上分享，希望對大家能有所幫助。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 3</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-3/</link>
      <pubDate>Tue, 22 Dec 2020 19:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-3/</guid>
      <description>本文 繼續接著進行後續步驟。
刪除使用者 1、建立 空的Controller。
/// &amp;lt;summary&amp;gt; /// 刪除帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;parameter&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [Route(&amp;quot;&amp;quot;)] [HttpDelete] public ResultViewModel RemoveAccount([FromBody]AccountParameter parameter) { } 2、建立 Service介面。
/// &amp;lt;summary&amp;gt; /// 刪除帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public ResultDto RemoveAccount(AccountInfoModel info); 3、建立 空的Service實作。
/// &amp;lt;summary&amp;gt; /// 刪除帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public ResultDto RemoveAccount(AccountInfoModel info) { throw new NotImplementedException(); } 4、建立 Repository介面。
/// &amp;lt;summary&amp;gt; /// 刪除帳號 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;account&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool RemoveAccount(string account); 5、實作 Repository。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 2</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-2/</link>
      <pubDate>Mon, 21 Dec 2020 21:50:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-2/</guid>
      <description>本文 先來看進度表。
 1、新增使用者。 2、取得所有使用者。 3、取得個別使用者。 4、刪除使用者。 5、使用者更新基本資料。 6、忘記密碼。  既然已經完成取得個別使用者，那我們就從取得帳號列表接續進行。
取得帳號列表 1、先建立一個空的Controller方法，這邊因為取得List，所以會是一個Array使用IEnumerable來包Model。
/// 取得帳號列表 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [Route(&amp;quot;&amp;quot;)] [HttpGet] public IEnumerable&amp;lt;AccountViewModel&amp;gt; GetAccountList() { } 2、建立 取得帳號列表Service介面。
/// &amp;lt;summary&amp;gt; /// 取得帳號列表 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public IEnumerable&amp;lt;AccountDto&amp;gt; GetAccountList(); 3、實作 取得帳號列表空的Service。
/// &amp;lt;summary&amp;gt; /// 取得帳號列表 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public IEnumerable&amp;lt;AccountDto&amp;gt; GetAccountList() { throw new NotImplementedException(); } 4、建立 取得帳號列表Repository介面。
/// &amp;lt;summary&amp;gt; /// 取得帳號列表 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public IEnumerable&amp;lt;AccountDataModel&amp;gt; GetAccountList(); 5、實作 取得帳號列表Repository方法。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 1</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-1/</link>
      <pubDate>Tue, 15 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-1/</guid>
      <description>本文 進度欄。 這邊附上同事提供的建一個新專案需要完成的步驟，我加以改成自己習慣的方式。 再次幫推廣他的部落格
 1. 建立 Service 2. 建立 Repository 3. 建立 FirstController 要傳接的Model(Parameter、ViewModel) 4. 建立空的 FirstController (First = 主要功能) 5. 建立 FirstService 要傳接的Model(InfoModel、Dto) 6. 建立 FirstService 介面 和一個空的 GetXXX 方法（XXX = 查詢之類的） 7. 建立 FirstRepository 要傳接的Model(Condition、DataModel) 8. 建立 FirstRepository 介面 和一個空的 GetXXX 方法 9. 將 Service 注入到 Controller, 將 Repository 注入到 Service 10. 安裝 AutoMapper 11. 將 AutoMapper 注入到 Controller, Service 12. Controller Get 方法和 Service Get 方法對接 13.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 0</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</link>
      <pubDate>Thu, 03 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</guid>
      <description>前言 前面介紹了三層式架構、DI，接下來就是要來實做啦。
這次的實作會自己設計一張Table，並設計API情境，當練習寫SPEC；所以這篇是前置動作準備。
本文 1、資料庫準備。 首先這次打算做一個使用者管理功能，所以先來建造Table，就直接放在先前的Norwind底下就可以了。
CREATE TABLE Users ( Idx INT IDENTITY, Account varchar(30) PRIMARY KEY NOT NULL, Password varchar(50) NOT NULL, Phone varchar(20) NOT NULL, Email varchar(50) NOT NULL, CreateDate DATETIME NOT NULL, ModifyDate DATETIME NOT NULL, ModifyUser varchar(30) NOT NULL ); 建立完後重新整理即可在Northwind底下看到新Table。
新增一筆資料測試。
Insert into [Northwind].[dbo].[Users] ([Account] ,[Password] ,[Phone] ,[Email] ,[CreateDate] ,[ModifyDate] ,[ModifyUser]) values(&#39;ss123456&#39;,&#39;esetttt&#39;,&#39;0917444&#39;,&#39;ew@gmail.com&#39;,GETDATE(),GETDATE(),&#39;system&#39;) 2、API SPEC。 首先我們會需要的功能有：
   功能     1、新增使用者。   2、取得所有使用者。   3、取得個別使用者。   4、刪除使用者。   5、使用者更新基本資料。   6、忘記密碼。    功能細項規格：</description>
    </item>
    
    <item>
      <title>依賴注入 DI(Dependency Injection)</title>
      <link>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</link>
      <pubDate>Wed, 02 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</guid>
      <description>前言 終於寫到DI了，這應該是一開始學習三層式架構後的第二座高山，直到今天我也還不敢稱自己完全懂，頂多只能說是會用，剛好藉著這次機會複習概念。
本文 講解DI前會有兩個先行觀念需要了解，分別是：
 1、DIP(Dependency Inversion Principle) 依賴反轉。 2、IOC(Inversion of Control) 控制反轉。  1、DIP 依賴反轉。 複習一下前面講解到的依賴反轉概念：
我們了解到DIP最重要的目標是要解除物件與物間之間直接依賴的關係。
不熟的同學起點這複習。
2、IOC 控制反轉。 那甚麼又是控制反轉呢？
控制反轉最重要的概念是：
把對於某個物件的控制權移轉給第三方容器。 甚麼意思呢？
回憶一下，還記得前面實作的第一版API嗎？
我們的Controller在跟Repository要資料的時候是怎麼做的呢？ 看到關鍵字了嗎？
沒有？那這樣呢？
就是那個NEW代表著我們的Controller其實是直接依賴Repository的。
他們之間的關係如下圖。
所以理想中IOC概念我們的關係圖應該長這樣： 我們的Controller應該把對於Repository的控制權移交給IOC。
3、DI 依賴注入。 講了這麼多那所以甚麼是DI呢？
聰明的同學應該發現了上述的DIP、IOC都只是一種精神、概念；而DI就是實現上述兩種精神的方法。
講解DI的精神最經典的就是：  好萊塢原則 (Hollywood Principle)
don‘t call us, we‘ll call you
在好萊塢演員要應徵的時候僅需要把履歷上繳，之後剩下的就只能等待演藝公司通知。
這就是一種被動接受的方式。  所以呢有了DI的概念我們理想中的關係圖應該要變成： 4、注入的方式。 注入的方式有以下三種：
 a、建構式注入 (Constructor Injection) b、設值方法注入 (Setter Injection) c、介面注入 (Interface Injection)  以我們先前的Controller進行示範
public class ProductContorller : ControllerBase { //a、建構式注入 private readonly IProductRepository _productRepository; public ProductContorller( IProductRepository productRepository) { this.</description>
    </item>
    
    <item>
      <title>Automapper 類別轉換好用工具</title>
      <link>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>前言 上一篇介紹了三層式架構，有些人可能會有疑問，三層各有自己的Model，那要怎麼將各個Model轉換呢？
難道是每一次轉換都需要跑一次迴圈，那也太麻煩了；這時就要介紹好用的工具Automapper了。
本文 基本用法 首先到Nuget安裝Automapper。 安裝好後我們建立兩個測試用的Model
private class Model1 { public string Name { get; set; } public int Id { get; set; } } private class Model2 { public string Name { get; set; } public int Id { get; set; } } 使用Automapper對應Model1到Model2。
var testModel = new Model1 { Name = &amp;quot;ALLEN&amp;quot;, Id = 1 }; var config = new MapperConfiguration(cfg =&amp;gt; cfg.CreateMap&amp;lt;Model1, Model2&amp;gt;()); //從左邊Model對應到右邊 var mapper = config.</description>
    </item>
    
    <item>
      <title>三層式架構</title>
      <link>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</link>
      <pubDate>Sun, 15 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</guid>
      <description>前言 接下來開始講解三層式架構，這是工作以來第一個學會的架構，也使用了一段時間，就以這段時間自己的體悟來敘述。
本文 為甚麼要分層呢？ 前一篇我們提到，如果程式全部一條龍寫到底，後續會產生很多問題，難以維護、難以閱讀、更甚至是萬一人家要接手你的程式碼，這時候改Ａ壞Ｂ，耦合度過高的情況下，你只能祈禱接手的人不知道你住哪。
這種情況下只有自己寫可能還好，那如果需要跟人合作呢？
大家可能容易出現重複的Code，也難以說明誰該負責寫哪部分。
這時候有一個好的架構，就很重要了。
優缺點    優點     1、較好形成一個規範，可做為標準化流程。   2、提高重用性，透過分層將相同類型的程式碼放在一塊。   3、團體合作的時候，能夠分層進行；開發人員只需專注於自己開發的那一層即可。   4、具有好的開放性、可擴充性優點。   5、降低程式碼之間的依賴，每層溝通是透過介面。   6、提高系統安全性，因為使用者需要透過Service層才有機會與下一層Repository撈取資料。       缺點     1、增加了開發成本，傳統一個人負責寫到底；分層下需要多人進行合作。   2、調整程式可能會出現連動性；有的時候修改一個地方，會導致其他層也需要跟著調整。   3、相較於一條龍開發系統性能下降，原本程式可以直接透過DB撈取資料，現在需要透過中間層的轉介才能夠拿到。    簡介 三層式架構顧名思義，主要分為了三層：
 1、Controller：控制層，作為接口。 2、Service：商業邏輯層，只要有關商業邏輯部分的處理全部放在這一層。 3、Repository：倉儲層，作為資料存儲的一層。 4、Common：共用層，作為存放各層會用到的相同東西。  他們之間的關係如下圖:
Service 從最重要的Service層開始講解起。
在我們程式中『最重要』的就屬於商業邏輯了，這一層是會特別關注的一層；這邊大家可能會問，那商業邏輯是指哪些呢？
我自己認為最簡單分辨的方式，舉凡任何需要對資料特別處理的地方都會是放在這一層，如常見的：登入驗證、加減法運算、確認是否驗證成功等。
Controller 在我們WebAPI中，Controller就屬於接口，負責處理Router，如常見的：Get、Post、Patch等，都會是在這層負責接應相對應的路由。
Repository 資料倉儲層，這層主要處理『有關資料串接』的部分，如：資料庫連接、下SQL取Table資料等，都會是在Repository處理。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-5 小結分析</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 10 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</guid>
      <description>本文 先前完成了API，接下來聊聊目前這樣做法可能會碰到的問題。
1、程式碼四散。 現在做法是從Controller決定執行動作後，到Repository撈取DB資料後回傳json；那麼今天假如有要處理的關鍵商業邏輯，是該寫在Controller或是Repository呢？
又如果今天多人合作的情況下，甲覺得應該放在Repository、而乙覺得應該放在Controller，這樣就會造成程式碼四散，對後續要維護的人造成很大的困擾。
2、容易有重工。 現行做法如果多人合作的時候，可以用Repository名稱來定義是從哪個DB撈取資料；Controller也可以明確定義出接口，那承上所述的商業邏輯呢？又或是因為大家要處理的Model不同因此再合作的時候建了一堆不同的Model出來，卻其實是撈同一個Table的資料，應該想辦法避免做重複的事情。
3、耦合過高。 現行做法很容易再單一的class做了太多事，還記得前幾篇提到的SOLID原則嗎？若所有事情都包在同一個class中完成，藕合度就會過高這種情況應該要想辦法解決。
那有甚麼好方法呢？ 像傳統的MVC就是把程式分成Model-View-Controller。
 1、Model：處理商業邏輯、資料傳輸的Model、與資料庫進行溝通。 2、Controller：負責當接口、控制程式的流程。 3、View：負責呈現，ex:畫面啦、程式應該回傳的結果。  透過將程式分開讓藕合性降低、也讓後續維護者好維護。
其他如:DDD、三層式架構等，都有自己得優缺點，下篇我們會介紹三層式架構，再將API實作。
參考連結  1、維基百科MVC。 2、MVC 架構與說明 ( 以Asp .Net MVC C# 為例 ) 3、MVC 三層架構 是什麼? 我只知道三層肉  </description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-4 RESTful API介紹</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Thu, 29 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</guid>
      <description>本文 REST是Representational State Transfer的縮寫，是一種設計模式，RESTful API就是遵循這種設計模式所創造的API。
那RESTful是怎樣的一個設計模式呢? 首先組成RESTful API三大要素有:
   組成要素 說明     1、Nouns (名詞) 一組獨一無二的URL用來定義網址。   2、Verbs (動詞) 用來描述對URL所執行的動作，也就是HTTP Method。   3、Content Types(資源呈現方式) API資源呈現的方式 EX:JSON、XML。    以前幾篇的API為範例:
   Method router 說明     GET api/Product 取得商品列表   POST api/Product 新增商品   PATCH api/Product 修改商品資訊   DELETE api/Product/85 商除指定商品    固定的Router，但使用Method來區分要進行的動作，好處是不會有五花八門的router出現，一旦用了此種模式，大家就能輕易區分API會做些甚麼，我該取用哪隻API。
常見的Method有以下幾種:
   Method 說明     GET 讀取資料   POST 新增資料，亦可作為其他動詞使用。   PUT 更新   PATCH 部分更新資料   DELETE 刪除資料    備註: POST被視作萬用動詞，可以作為其他動作。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-3</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</link>
      <pubDate>Mon, 12 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</guid>
      <description>本文 修改 1、修改指定商品 Repository
/// &amp;lt;summary&amp;gt;  /// 修改商品內容  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;productModel&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool UpdateProduct(ProductModel productModel) { var sql = @&amp;#34;UPDATE products SET productname = @ProductName, supplierid = @SupplierID, categoryid = @CategoryID, quantityperunit = @QuantityPerUnit, unitprice = @UnitPrice, unitsinstock = @UnitsInStock, unitsonorder = @UnitsOnOrder, reorderlevel = @ReorderLevel, discontinued = @Discontinued WHERE productid = @ProductID &amp;#34;; var parameters = new DynamicParameters(); parameters.Add(&amp;#34;@ProductName&amp;#34;, productModel.ProductName); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-2</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</link>
      <pubDate>Tue, 29 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</guid>
      <description>前言 我們接續著上次的介紹，會把CRUD功能補齊。
CRUD指的是Create(新增)、Read(查詢)、Delete(刪除)、Update(更新)，也是最常運用到的功能。
本文 新增 1、首先我們先建立一個用來回傳的Model。
建立 ResultModel
public class ResultModel { /// &amp;lt;summary&amp;gt;  /// 結果  /// &amp;lt;/summary&amp;gt;  public bool Result { get; set; } /// &amp;lt;summary&amp;gt;  /// 提示訊息  /// &amp;lt;/summary&amp;gt;  public string Message { get; set; } } 2、把新增商品的Repository完成。
新增商品Repository
/// &amp;lt;summary&amp;gt; /// 新增一筆商品 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;productModel&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool CreateProduct(ProductModel productModel) { var sql = @&amp;quot;INSERT INTO products (productname, supplierid, categoryid, quantityperunit, unitprice, unitsinstock, unitsonorder, reorderlevel, discontinued) VALUES (@ProductName, @SupplierID, @CategoryID, @QuantityPerUnit, @UnitPrice, @UnitsInStock, @UnitsOnOrder, @ReorderLevel, @Discontinued) &amp;quot;; var parameters = new DynamicParameters(); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper)-1</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</link>
      <pubDate>Tue, 22 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</guid>
      <description>前言 終於進入WebApi部分，也是目前工作最常做的一部分。
這邊會從原始MVC作為開頭介紹，內容會帶入Dapper、Restful介紹，以及一些好用小工具分享。
本文 一、事前準備 1、首先我們先建立一個core專案。 選擇API建立 2、資料庫準備。 先到此連結下載北風資料庫
點選instnwnd.sql，選擇Download。 會看到瀏覽器顯示一長串SQL語法，把這邊全部複製起來。 到SSMS點選新增查詢，把語法貼上後執行。 看到資料庫出現Northwind代表成功。 二、API開發 1、首先我們建立一個Models資料夾。 建立一個ProductModel類別，對應北風資料庫的Products。 建立 ProductModel
public class ProductModel { /// &amp;lt;summary&amp;gt;  /// 商品流水號  /// &amp;lt;/summary&amp;gt;  public int ProductID { get; set; } /// &amp;lt;summary&amp;gt;  /// 商品名稱  /// &amp;lt;/summary&amp;gt;  public string ProductName { get; set; } /// &amp;lt;summary&amp;gt;  /// 供應商ID  /// &amp;lt;/summary&amp;gt;  public int SupplierID { get; set; } /// &amp;lt;summary&amp;gt;  /// 種類ID  /// &amp;lt;/summary&amp;gt;  public int CategoryID { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位數量  /// &amp;lt;/summary&amp;gt;  public string QuantityPerUnit { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位價格  /// &amp;lt;/summary&amp;gt;  public decimal UnitPrice { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位稅額  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsInStock { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位訂購價  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsOnOrder { get; set; } /// &amp;lt;summary&amp;gt;  /// 重新訂購等級  /// &amp;lt;/summary&amp;gt;  public Int16 ReorderLevel { get; set; } /// &amp;lt;summary&amp;gt;  /// 是否已停產  /// &amp;lt;/summary&amp;gt;  public bool Discontinued { get; set; } } 這邊各欄位的型態可以先看DB內資料類型</description>
    </item>
    
    <item>
      <title>Puppeteer Sharp網頁截圖轉成pdf</title>
      <link>https://sunnyday0932.github.io/2020/puppeteer-sharp%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf/</link>
      <pubDate>Tue, 04 Aug 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/puppeteer-sharp%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf/</guid>
      <description>前言 你聽過隕石開發法嗎？
沒聽過？那你可以看看轉載好文:隕石開發法
甚麼？你問隕石開發法跟這篇文有甚麼關係？
因為神有了需求 本文 上次有提到Puppeteer Sharp這個套件、以及黑大這篇文C# 整合 Headless Chrome 的好工具 - Puppeteer Sharp，但因為我的chromium版本一直無法運行就此作罷；直到主管突然提起同單位有人成功使用這個套件實作出功能。
 這時候別人用了同工具可以，沒道理我不行的心就蠢蠢欲動了。  把問題倒回碰到的起始點，是chromium無法運行，想想應該是套件抓下來的版本有問題，於是我研究了一下chromuim的版本，官方文件在此，發現版本其實分很多種，有開發版、測試版、穩定版，於是研究了一下就到此網址下載了官方提供版本更換套件內抓取的chromium測試。
1、 先到專案資料夾底下bin &amp;gt; Debugger &amp;gt; .local-chromium 內。 2、將下載版本複製貼上並取代此資料夾內檔案。 3、進行測試。
static void Main(string[] args) { Test().Wait(); } static async Task Test() { try { await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultRevision); using (var browser = await Puppeteer.LaunchAsync(new LaunchOptions() { Headless = true //偵測時可設定false觀察網頁顯示結果(註：非Headless時不能匯出PDF)  })) { using (var page = await browser.NewPageAsync()) { await page.GoToAsync(&amp;#34;https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/&amp;#34;); Thread.Sleep(1000); await page.</description>
    </item>
    
    <item>
      <title>網頁截圖轉成pdf檔(純屬好玩)</title>
      <link>https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/</link>
      <pubDate>Thu, 23 Jul 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96%E8%BD%89%E6%88%90pdf%E6%AA%94%E7%B4%94%E5%B1%AC%E5%A5%BD%E7%8E%A9/</guid>
      <description>前言 昨天接到一個新需求，需要用Url連結到其他網頁將該頁面截圖後，轉換成pdf檔供使用者下載。
今天研究了一下覺得好玩紀錄一下。
本文 接到需求後一開始是用 .NET Webpage to pdf當關鍵字搜尋，無奈找了幾個套件不是要收費就是已經年代久遠，最後用中文搜尋到了黑大去年寫的一篇文章。
C# 整合 Headless Chrome 的好工具 - Puppeteer Sharp
此篇是用Puppeteer Sharp這個套件將網頁截圖後儲存，套件資訊可以自行參閱。
Puppeteer Sharp是使用Chromium幫你截圖網站頁面，所以其實後背後運作 .NET還是有幫你開啟網頁的。
無奈今天嘗試後遇到 Failed to launch chrome 錯誤。
Google後發現很多人都有遇到類似問題，有很多人發issue給作者。
最後決定回頭繼續搜尋其他方式，這時候發現黑大今年又寫了另一篇文章。
C# 網頁轉圖檔 WebAPI - 青春版
這方法使用的是原生System.Web.Forms.WebBrowser方式擷取網頁圖片，一樣的 .NET有幫你開啟網頁進行截圖的動作，只是這個原生的方式就是使用IE。
測試的此方式可行後我就開始尋找第二步動作，該怎麼把圖檔轉換成pdf，於是找到了另一個套件iTextSharp。
可以套過套件將圖檔直接轉換成pdf的強大方法。
將黑大的方法結合iTextSharp就能得到想到的結果如下&amp;hellip;
private static void Main(string[] args) { string url = null; var png = WebSnapTool.Snapshot(url ?? &amp;#34;https://sunnyday0932.github.io/2020/object-oriented%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87solid-1_single-responsibility-principlesrp-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC/&amp;#34;, delaySecs: 0); using (var stream = File.Create(@&amp;#34;D:\test\test.pdf&amp;#34;)) using (var doc = new Document()) using (var pdfWriter = PdfWriter.</description>
    </item>
    
    <item>
      <title>Json格式轉換，序列化(Serialize)與反序列化(Deserialize)</title>
      <link>https://sunnyday0932.github.io/2020/json%E6%A0%BC%E5%BC%8F%E8%BD%89%E6%8F%9B%E5%BA%8F%E5%88%97%E5%8C%96serialize%E8%88%87%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96deserialize/</link>
      <pubDate>Tue, 30 Jun 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/json%E6%A0%BC%E5%BC%8F%E8%BD%89%E6%8F%9B%E5%BA%8F%E5%88%97%E5%8C%96serialize%E8%88%87%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96deserialize/</guid>
      <description>前言 今天在工作上剛好碰到了要將字串轉換成Json格式傳遞給別人，遇到了有趣的事情特別記錄一下。
本文 一開始很好奇我擷取的字串出來序列化的Json格式，會多出空行的符號\r\n。
&amp;#34;{\&amp;#34;A\&amp;#34;:\&amp;#34;ss\r\nss\&amp;#34;,\&amp;#34;B\&amp;#34;:\&amp;#34;ss\nss\&amp;#34;}&amp;#34; 於是就跟同事討論起這件事，我一開始想法是這是不是會影響別人收到後處理結果呢?
同事做了簡單範例解釋。
class Program { static void Main(string[] args) { var objTest = new Test { A = &amp;#34;ss\r\nss&amp;#34;, B = &amp;#34;ss\nss&amp;#34; }; var jsonObj = JsonConvert.SerializeObject(objTest); Console.WriteLine(jsonObj); var obj2 = JsonConvert.DeserializeObject&amp;lt;Test&amp;gt;(&amp;#34;{\&amp;#34;A\&amp;#34;:\&amp;#34;ss\r\nss\&amp;#34;,\&amp;#34;B\&amp;#34;:\&amp;#34;ss\nss\&amp;#34;}&amp;#34;); Console.WriteLine(obj2.A); Console.WriteLine(obj2.B); } public class Test { public string A { get; set; } public string B { get; set; } } } 輸出結果
Json格式會有自己特殊的跳脫字元，而在反序列化中程式就會將字串轉換成我們看到的正常樣貌。
所以結論就是，通通丟給對方處理就對了🤟
參考連結  1、Json官方文件 2、瞭解Json格式  </description>
    </item>
    
  </channel>
</rss>
