<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Core on Sian</title>
    <link>https://sunnyday0932.github.io/tags/core/</link>
    <description>Recent content in Core on Sian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Tue, 15 Dec 2020 22:19:33 +0800</lastBuildDate><atom:link href="https://sunnyday0932.github.io/tags/core/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>dotnet Core WebApi(Phase2) - 1</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-1/</link>
      <pubDate>Tue, 15 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-1/</guid>
      <description>本文 進度欄。 這邊附上同事提供的建一個新專案需要完成的步驟，我加以改成自己習慣的方式。 再次幫推廣他的部落格
 1. 建立 Service 2. 建立 Repository 3. 建立 FirstController 要傳接的Model(Parameter、ViewModel) 4. 建立空的 FirstController (First = 主要功能) 5. 建立 FirstService 要傳接的Model(InfoModel、Dto) 6. 建立 FirstService 介面 和一個空的 GetXXX 方法（XXX = 查詢之類的） 7. 建立 FirstRepository 要傳接的Model(Condition、DataModel) 8. 建立 FirstRepository 介面 和一個空的 GetXXX 方法 9. 將 Service 注入到 Controller, 將 Repository 注入到 Service 10. 安裝 AutoMapper 11. 將 AutoMapper 注入到 Controller, Service 12. Controller Get 方法和 Service Get 方法對接 13.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi(Phase2) - 0</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</link>
      <pubDate>Thu, 03 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapiphase2-0/</guid>
      <description>前言 前面介紹了三層式架構、DI，接下來就是要來實做啦。
這次的實作會自己設計一張Table，並設計API情境，當練習寫SPEC；所以這篇是前置動作準備。
本文 1、資料庫準備。 首先這次打算做一個使用者管理功能，所以先來建造Table，就直接放在先前的Norwind底下就可以了。
CREATE TABLE Users ( Idx INT IDENTITY, Account varchar(30) PRIMARY KEY NOT NULL, Password varchar(50) NOT NULL, Phone varchar(20) NOT NULL, Email varchar(50) NOT NULL, CreateDate DATETIME NOT NULL, ModifyDate DATETIME NOT NULL, ModifyUser varchar(30) NOT NULL ); 建立完後重新整理即可在Northwind底下看到新Table。
新增一筆資料測試。
Insert into [Northwind].[dbo].[Users] ([Account] ,[Password] ,[Phone] ,[Email] ,[CreateDate] ,[ModifyDate] ,[ModifyUser]) values(&#39;ss123456&#39;,&#39;esetttt&#39;,&#39;0917444&#39;,&#39;ew@gmail.com&#39;,GETDATE(),GETDATE(),&#39;system&#39;) 2、API SPEC。 首先我們會需要的功能有：
   功能     1、新增使用者。   2、取得所有使用者。   3、取得個別使用者。   4、刪除使用者。   5、使用者更新基本資料。   6、忘記密碼。    功能細項規格：</description>
    </item>
    
    <item>
      <title>依賴注入 DI(Dependency Injection)</title>
      <link>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</link>
      <pubDate>Wed, 02 Dec 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5-didependency-injection/</guid>
      <description>前言 終於寫到DI了，這應該是一開始學習三層式架構後的第二座高山，直到今天我也還不敢稱自己完全懂，頂多只能說是會用，剛好藉著這次機會複習概念。
本文 講解DI前會有兩個先行觀念需要了解，分別是：
 1、DIP(Dependency Inversion Principle) 依賴反轉。 2、IOC(Inversion of Control) 控制反轉。  1、DIP 依賴反轉。 複習一下前面講解到的依賴反轉概念：
我們了解到DIP最重要的目標是要解除物件與物間之間直接依賴的關係。
不熟的同學起點這複習。
2、IOC 控制反轉。 那甚麼又是控制反轉呢？
控制反轉最重要的概念是：
把對於某個物件的控制權移轉給第三方容器。 甚麼意思呢？
回憶一下，還記得前面實作的第一版API嗎？
我們的Controller在跟Repository要資料的時候是怎麼做的呢？ 看到關鍵字了嗎？
沒有？那這樣呢？
就是那個NEW代表著我們的Controller其實是直接依賴Repository的。
他們之間的關係如下圖。
所以理想中IOC概念我們的關係圖應該長這樣： 我們的Controller應該把對於Repository的控制權移交給IOC。
3、DI 依賴注入。 講了這麼多那所以甚麼是DI呢？
聰明的同學應該發現了上述的DIP、IOC都只是一種精神、概念；而DI就是實現上述兩種精神的方法。
講解DI的精神最經典的就是：  好萊塢原則 (Hollywood Principle)
don‘t call us, we‘ll call you
在好萊塢演員要應徵的時候僅需要把履歷上繳，之後剩下的就只能等待演藝公司通知。
這就是一種被動接受的方式。  所以呢有了DI的概念我們理想中的關係圖應該要變成： 4、注入的方式。 注入的方式有以下三種：
 a、建構式注入 (Constructor Injection) b、設值方法注入 (Setter Injection) c、介面注入 (Interface Injection)  以我們先前的Controller進行示範
public class ProductContorller : ControllerBase { //a、建構式注入 private readonly IProductRepository _productRepository; public ProductContorller( IProductRepository productRepository) { this.</description>
    </item>
    
    <item>
      <title>Automapper 類別轉換好用工具</title>
      <link>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/automapper-%E9%A1%9E%E5%88%A5%E8%BD%89%E6%8F%9B%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>前言 上一篇介紹了三層式架構，有些人可能會有疑問，三層各有自己的Model，那要怎麼將各個Model轉換呢？
難道是每一次轉換都需要跑一次迴圈，那也太麻煩了；這時就要介紹好用的工具Automapper了。
本文 基本用法 首先到Nuget安裝Automapper。 安裝好後我們建立兩個測試用的Model
private class Model1 { public string Name { get; set; } public int Id { get; set; } } private class Model2 { public string Name { get; set; } public int Id { get; set; } } 使用Automapper對應Model1到Model2。
var testModel = new Model1 { Name = &amp;quot;ALLEN&amp;quot;, Id = 1 }; var config = new MapperConfiguration(cfg =&amp;gt; cfg.CreateMap&amp;lt;Model1, Model2&amp;gt;()); //從左邊Model對應到右邊 var mapper = config.</description>
    </item>
    
    <item>
      <title>三層式架構</title>
      <link>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</link>
      <pubDate>Sun, 15 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</guid>
      <description>前言 接下來開始講解三層式架構，這是工作以來第一個學會的架構，也使用了一段時間，就以這段時間自己的體悟來敘述。
本文 為甚麼要分層呢？ 前一篇我們提到，如果程式全部一條龍寫到底，後續會產生很多問題，難以維護、難以閱讀、更甚至是萬一人家要接手你的程式碼，這時候改Ａ壞Ｂ，耦合度過高的情況下，你只能祈禱接手的人不知道你住哪。
這種情況下只有自己寫可能還好，那如果需要跟人合作呢？
大家可能容易出現重複的Code，也難以說明誰該負責寫哪部分。
這時候有一個好的架構，就很重要了。
優缺點    優點     1、較好形成一個規範，可做為標準化流程。   2、提高重用性，透過分層將相同類型的程式碼放在一塊。   3、團體合作的時候，能夠分層進行；開發人員只需專注於自己開發的那一層即可。   4、具有好的開放性、可擴充性優點。   5、降低程式碼之間的依賴，每層溝通是透過介面。   6、提高系統安全性，因為使用者需要透過Service層才有機會與下一層Repository撈取資料。       缺點     1、增加了開發成本，傳統一個人負責寫到底；分層下需要多人進行合作。   2、調整程式可能會出現連動性；有的時候修改一個地方，會導致其他層也需要跟著調整。   3、相較於一條龍開發系統性能下降，原本程式可以直接透過DB撈取資料，現在需要透過中間層的轉介才能夠拿到。    簡介 三層式架構顧名思義，主要分為了三層：
 1、Controller：控制層，作為接口。 2、Service：商業邏輯層，只要有關商業邏輯部分的處理全部放在這一層。 3、Repository：倉儲層，作為資料存儲的一層。 4、Common：共用層，作為存放各層會用到的相同東西。  他們之間的關係如下圖:
Service 從最重要的Service層開始講解起。
在我們程式中『最重要』的就屬於商業邏輯了，這一層是會特別關注的一層；這邊大家可能會問，那商業邏輯是指哪些呢？
我自己認為最簡單分辨的方式，舉凡任何需要對資料特別處理的地方都會是放在這一層，如常見的：登入驗證、加減法運算、確認是否驗證成功等。
Controller 在我們WebAPI中，Controller就屬於接口，負責處理Router，如常見的：Get、Post、Patch等，都會是在這層負責接應相對應的路由。
Repository 資料倉儲層，這層主要處理『有關資料串接』的部分，如：資料庫連接、下SQL取Table資料等，都會是在Repository處理。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-5 小結分析</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 10 Nov 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-5-%E5%B0%8F%E7%B5%90%E5%88%86%E6%9E%90/</guid>
      <description>本文 先前完成了API，接下來聊聊目前這樣做法可能會碰到的問題。
1、程式碼四散。 現在做法是從Controller決定執行動作後，到Repository撈取DB資料後回傳json；那麼今天假如有要處理的關鍵商業邏輯，是該寫在Controller或是Repository呢？
又如果今天多人合作的情況下，甲覺得應該放在Repository、而乙覺得應該放在Controller，這樣就會造成程式碼四散，對後續要維護的人造成很大的困擾。
2、容易有重工。 現行做法如果多人合作的時候，可以用Repository名稱來定義是從哪個DB撈取資料；Controller也可以明確定義出接口，那承上所述的商業邏輯呢？又或是因為大家要處理的Model不同因此再合作的時候建了一堆不同的Model出來，卻其實是撈同一個Table的資料，應該想辦法避免做重複的事情。
3、耦合過高。 現行做法很容易再單一的class做了太多事，還記得前幾篇提到的SOLID原則嗎？若所有事情都包在同一個class中完成，藕合度就會過高這種情況應該要想辦法解決。
那有甚麼好方法呢？ 像傳統的MVC就是把程式分成Model-View-Controller。
 1、Model：處理商業邏輯、資料傳輸的Model、與資料庫進行溝通。 2、Controller：負責當接口、控制程式的流程。 3、View：負責呈現，ex:畫面啦、程式應該回傳的結果。  透過將程式分開讓藕合性降低、也讓後續維護者好維護。
其他如:DDD、三層式架構等，都有自己得優缺點，下篇我們會介紹三層式架構，再將API實作。
參考連結  1、維基百科MVC。 2、MVC 架構與說明 ( 以Asp .Net MVC C# 為例 ) 3、MVC 三層架構 是什麼? 我只知道三層肉  </description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作-4 RESTful API介紹</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Thu, 29 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C-4-restful-api%E4%BB%8B%E7%B4%B9/</guid>
      <description>本文 REST是Representational State Transfer的縮寫，是一種設計模式，RESTful API就是遵循這種設計模式所創造的API。
那RESTful是怎樣的一個設計模式呢? 首先組成RESTful API三大要素有:
   組成要素 說明     1、Nouns (名詞) 一組獨一無二的URL用來定義網址。   2、Verbs (動詞) 用來描述對URL所執行的動作，也就是HTTP Method。   3、Content Types(資源呈現方式) API資源呈現的方式 EX:JSON、XML。    以前幾篇的API為範例:
   Method router 說明     GET api/Product 取得商品列表   POST api/Product 新增商品   PATCH api/Product 修改商品資訊   DELETE api/Product/85 商除指定商品    固定的Router，但使用Method來區分要進行的動作，好處是不會有五花八門的router出現，一旦用了此種模式，大家就能輕易區分API會做些甚麼，我該取用哪隻API。
常見的Method有以下幾種:
   Method 說明     GET 讀取資料   POST 新增資料，亦可作為其他動詞使用。   PUT 更新   PATCH 部分更新資料   DELETE 刪除資料    備註: POST被視作萬用動詞，可以作為其他動作。</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-3</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</link>
      <pubDate>Mon, 12 Oct 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-3/</guid>
      <description>本文 修改 1、修改指定商品 Repository
/// &amp;lt;summary&amp;gt;  /// 修改商品內容  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;productModel&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool UpdateProduct(ProductModel productModel) { var sql = @&amp;#34;UPDATE products SET productname = @ProductName, supplierid = @SupplierID, categoryid = @CategoryID, quantityperunit = @QuantityPerUnit, unitprice = @UnitPrice, unitsinstock = @UnitsInStock, unitsonorder = @UnitsOnOrder, reorderlevel = @ReorderLevel, discontinued = @Discontinued WHERE productid = @ProductID &amp;#34;; var parameters = new DynamicParameters(); parameters.Add(&amp;#34;@ProductName&amp;#34;, productModel.ProductName); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper、Swagger、Postman)-2</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</link>
      <pubDate>Tue, 29 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapperswaggerpostman-2/</guid>
      <description>前言 我們接續著上次的介紹，會把CRUD功能補齊。
CRUD指的是Create(新增)、Read(查詢)、Delete(刪除)、Update(更新)，也是最常運用到的功能。
本文 新增 1、首先我們先建立一個用來回傳的Model。
建立 ResultModel
public class ResultModel { /// &amp;lt;summary&amp;gt;  /// 結果  /// &amp;lt;/summary&amp;gt;  public bool Result { get; set; } /// &amp;lt;summary&amp;gt;  /// 提示訊息  /// &amp;lt;/summary&amp;gt;  public string Message { get; set; } } 2、把新增商品的Repository完成。
新增商品Repository
/// &amp;lt;summary&amp;gt; /// 新增一筆商品 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;quot;productModel&amp;quot;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool CreateProduct(ProductModel productModel) { var sql = @&amp;quot;INSERT INTO products (productname, supplierid, categoryid, quantityperunit, unitprice, unitsinstock, unitsonorder, reorderlevel, discontinued) VALUES (@ProductName, @SupplierID, @CategoryID, @QuantityPerUnit, @UnitPrice, @UnitsInStock, @UnitsOnOrder, @ReorderLevel, @Discontinued) &amp;quot;; var parameters = new DynamicParameters(); parameters.</description>
    </item>
    
    <item>
      <title>dotnet Core WebApi實作(使用Dapper)-1</title>
      <link>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</link>
      <pubDate>Tue, 22 Sep 2020 22:19:33 +0800</pubDate>
      
      <guid>https://sunnyday0932.github.io/2020/dotnet-core-webapi%E5%AF%A6%E4%BD%9C%E4%BD%BF%E7%94%A8dapper-1/</guid>
      <description>前言 終於進入WebApi部分，也是目前工作最常做的一部分。
這邊會從原始MVC作為開頭介紹，內容會帶入Dapper、Restful介紹，以及一些好用小工具分享。
本文 一、事前準備 1、首先我們先建立一個core專案。 選擇API建立 2、資料庫準備。 先到此連結下載北風資料庫
點選instnwnd.sql，選擇Download。 會看到瀏覽器顯示一長串SQL語法，把這邊全部複製起來。 到SSMS點選新增查詢，把語法貼上後執行。 看到資料庫出現Northwind代表成功。 二、API開發 1、首先我們建立一個Models資料夾。 建立一個ProductModel類別，對應北風資料庫的Products。 建立 ProductModel
public class ProductModel { /// &amp;lt;summary&amp;gt;  /// 商品流水號  /// &amp;lt;/summary&amp;gt;  public int ProductID { get; set; } /// &amp;lt;summary&amp;gt;  /// 商品名稱  /// &amp;lt;/summary&amp;gt;  public string ProductName { get; set; } /// &amp;lt;summary&amp;gt;  /// 供應商ID  /// &amp;lt;/summary&amp;gt;  public int SupplierID { get; set; } /// &amp;lt;summary&amp;gt;  /// 種類ID  /// &amp;lt;/summary&amp;gt;  public int CategoryID { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位數量  /// &amp;lt;/summary&amp;gt;  public string QuantityPerUnit { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位價格  /// &amp;lt;/summary&amp;gt;  public decimal UnitPrice { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位稅額  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsInStock { get; set; } /// &amp;lt;summary&amp;gt;  /// 每單位訂購價  /// &amp;lt;/summary&amp;gt;  public Int16 UnitsOnOrder { get; set; } /// &amp;lt;summary&amp;gt;  /// 重新訂購等級  /// &amp;lt;/summary&amp;gt;  public Int16 ReorderLevel { get; set; } /// &amp;lt;summary&amp;gt;  /// 是否已停產  /// &amp;lt;/summary&amp;gt;  public bool Discontinued { get; set; } } 這邊各欄位的型態可以先看DB內資料類型</description>
    </item>
    
  </channel>
</rss>
