<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Message Queue on Sian</title>
    <link>https://sunnyday0932.github.io/tags/message-queue/</link>
    <description>Recent content in Message Queue on Sian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 10 May 2021 01:40:45 +0000</lastBuildDate><atom:link href="https://sunnyday0932.github.io/tags/message-queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Message Queue - 1(基本介紹)</title>
      <link>https://sunnyday0932.github.io/2021/message-queue-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</link>
      <pubDate>Mon, 10 May 2021 01:40:45 +0000</pubDate>
      
      <guid>https://sunnyday0932.github.io/2021/message-queue-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</guid>
      <description>前言 延續上述練習，接下來我們想做到，當HangFire撈取新Youbike資料的同時，讓系統能夠同步更新我們的快取資料確保使用者能夠拿到最即時的資料，這時候Message Queue就會派上用場，接下來就來研究看看Message Queue能做到那些事，以及如何實作。
本文 Application Intergration(系統整合) 在開始認識Message Queue之前我們需要先對系統整合有些許概念。
系統整合指的是：
一個完整的系統，不會只有一支程式在運作，而是有各種不同的程式各個相互合作下達成不同的任務，在合作的過程中就需要透過訊息傳遞的幫助來協助彼此間相互合作，這類的需求我們就稱之為系統整合需要做到的事。
Ex:設想一個工廠的運作也是如此，工廠內不會只有一個產線在運行，像是特斯拉的工廠，我們從源頭需要備料，每一個零件的組裝，到一個完整的汽車烤漆，層層都有各個產線需要完成的事情，而相互間溝通就是需要透過系統整合來協助達成。
而系統整合分為了以下幾種方式：
1、Filed Based Integration(檔案為主的整合方式)。 Source Appication(來源程式)會根據要處理的任務，產生相對應的檔案到指定的路徑中，而Proccess Appication(處理程式)就會一直監看資料夾內有沒有需要處理的任務，當有的時候就會取出檔案作相對應的處理，並將處理的結果放到合適的檔案存放區。
2、Shared Database Integration(共享資料庫的整合方式)。 Source Appication(來源程式)將要處理的任務寫入DB，Proccess Appication(處理程式)就會一直監看DB有沒有需要處理的任務，當有的時候就會取出任務作相對應的處理，並將處理的結果寫回到DB。
這種方式就有點像我們Hangfire的運作模式。
3、Direct Connection Integration(直接連結的整合方式)。 Source Appication(來源程式)透過提前協議好的連結方式(TCP/IP、Named pipe connection)，直接傳遞要處理的任務，傳遞的資料格式可能為(Binary、XML、JSON等)，Proccess Appication(處理程式)處理完任務後再將結果傳回。
4、Asynchronous Message Broker(透過Message Broker的非同步傳遞方式)。 來源程式(這邊會稱為:Producer Appication)將任務傳給Message Broker，Message Boker在透過佇列(Queue)的方式將任務排列先後順序，最後將任務傳遞給處理程式進行處理(這邊稱之為Consumer Application)。
這種類型的傳遞方式特點為：
 不限制傳遞的資料格式。 需要有一個Message Broker Middleware進行協助處理任務的排列。 非同步的溝通方式，Producer傳送訊息至Message Queue後不需要立即得到回應，可以先行處理其他事情。 Comsumer可以等到有空的時候再來處理任務。  所以這邊最大的特點是，將收發訊息的雙方進行了解耦合的動作，兩邊在開發上可以專注在開發自己的程式上、收送雙方也不需要彼此的實體位置(IP地址、接收訊息的程式在哪)僅需要把訊息往Message Broker送即可。
有著好的可靠性，訊息放在Queue中使得資料不容易流失、Comsumer就算暫時無法消化訊息也沒關係，Message Queue會暫時將資料存起來等到Comsumer有資源可以消化時再將訊息送出去。
架構上也可以達到彈性擴展，Poducer、Message Broker、Comsumer都可以依照需求增減，Message Queue也是微服務的架構下最主要的溝通模式。
RabbitMQ 這次我們要研究的Message Queue就是RabbitMQ。
主要的腳色有：
 Producer - 負責丟訊息到Queue的。 Consumer - 負責消化來自Queue的訊息。 Queue - 負責存放所需的資料，一樣有著First-In-First-Out的特性。 Exchange - 在Poducer與Queue中間的一個元件，如果有Exchage的時候Poducer不再是直接把Message丟給Queue，而是把Message丟給Exchange後，由他來決定要丟給誰，主要有四種方式</description>
    </item>
    
  </channel>
</rss>
